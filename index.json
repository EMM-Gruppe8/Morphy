{
  "api/Global.AstarPath.AstarDistribution.html": {
    "href": "api/Global.AstarPath.AstarDistribution.html",
    "title": "Enum AstarPath.AstarDistribution | Morpy",
    "keywords": "Enum AstarPath.AstarDistribution Information about where the package was downloaded Namespace : Global Assembly : cs.temp.dll.dll Syntax public enum AstarDistribution Fields Name Description AssetStore PackageManager WebsiteDownload"
  },
  "api/Global.AstarPath.html": {
    "href": "api/Global.AstarPath.html",
    "title": "Class AstarPath | Morpy",
    "keywords": "Class AstarPath Inheritance Object AstarPath Namespace : Global Assembly : cs.temp.dll.dll Syntax public class AstarPath : VersionedMonoBehaviour Fields active Returns the active AstarPath object in the scene. Note: This is only set if the AstarPath object has been initialized (which happens in Awake). Declaration public static AstarPath active Field Value Type Description AstarPath batchGraphUpdates Throttle graph updates and batch them to improve performance. If toggled, graph updates will batched and executed less often (specified by AstarPath.graphUpdateBatchingInterval . This can have a positive impact on pathfinding throughput since the pathfinding threads do not need to be stopped as often, and it reduces the overhead per graph update. All graph updates are still applied however, they are just batched together so that more of them are applied at the same time. However do not use this if you want minimal latency between a graph update being requested and it being applied. This only applies to graph updates requested using the AstarPath.UpdateGraphs(Bounds,System.Single) method. Not those requested using AstarPath.RegisterSafeUpdate(System.Action) or AstarPath.AddWorkItem(System.Action) . If you want to apply graph updates immediately at some point, you can call AstarPath.FlushGraphUpdates . See: graph-updates (view in online documentation for working links) Declaration public bool batchGraphUpdates Field Value Type Description Boolean Branch Which branch of the A* %Pathfinding Project is this release. Used when checking for updates so that users of the development versions can get notifications of development updates. Declaration public static readonly string Branch Field Value Type Description String colorSettings Reference to the color settings for this AstarPath object. Color settings include for example which color the nodes should be in, in the sceneview. Declaration public AstarColor colorSettings Field Value Type Description AstarColor data Holds all graph data Declaration public AstarData data Field Value Type Description AstarData debugFloor Low value to use for certain AstarPath.debugMode modes. For example if AstarPath.debugMode is set to G, this value will determine when the node will be completely red. Note: Only relevant in the editor See: AstarPath.debugRoof See: AstarPath.debugMode Declaration public float debugFloor Field Value Type Description Single debugMode The mode to use for drawing nodes in the sceneview. Note: Only relevant in the editor See: Pathfinding.GraphDebugMode Declaration public GraphDebugMode debugMode Field Value Type Description GraphDebugMode debugPathData The path to debug using gizmos. This is the path handler used to calculate the last path. It is used in the editor to draw debug information using gizmos. Declaration [NonSerialized] public PathHandler debugPathData Field Value Type Description PathHandler debugPathID The path ID to debug using gizmos Declaration [NonSerialized] public ushort debugPathID Field Value Type Description UInt16 debugRoof High value to use for certain AstarPath.debugMode modes. For example if AstarPath.debugMode is set to G, this value will determine when the node will be completely green. For the penalty debug mode, the nodes will be colored green when they have a penalty less than AstarPath.debugFloor and red when their penalty is greater or equal to this value and something between red and green otherwise. Note: Only relevant in the editor See: AstarPath.debugFloor See: AstarPath.debugMode Declaration public float debugRoof Field Value Type Description Single Distribution Used by the editor to guide the user to the correct place to download updates Declaration public static readonly AstarPath.AstarDistribution Distribution Field Value Type Description AstarPath.AstarDistribution euclideanEmbedding Holds settings for heuristic optimization. See: heuristic-opt (view in online documentation for working links) Declaration public EuclideanEmbedding euclideanEmbedding Field Value Type Description EuclideanEmbedding fullGetNearestSearch Do a full GetNearest search for all graphs. Additional searches will normally only be done on the graph which in the first fast search seemed to have the closest node. With this setting on, additional searches will be done on all graphs since the first check is not always completely accurate.\\n More technically: GetNearestForce on all graphs will be called if true, otherwise only on the one graph which's GetNearest search returned the best node.\\n Usually faster when disabled, but higher quality searches when enabled. When using a a navmesh or recast graph, for best quality, this setting should be combined with the Pathfinding.NavMeshGraph.accurateNearestNode setting set to true. Note: For the PointGraph this setting doesn't matter much as it has only one search mode. Declaration public bool fullGetNearestSearch Field Value Type Description Boolean graphUpdateBatchingInterval Minimum number of seconds between each batch of graph updates. If AstarPath.batchGraphUpdates is true, this defines the minimum number of seconds between each batch of graph updates. This can have a positive impact on pathfinding throughput since the pathfinding threads do not need to be stopped as often, and it reduces the overhead per graph update. All graph updates are still applied however, they are just batched together so that more of them are applied at the same time. Do not use this if you want minimal latency between a graph update being requested and it being applied. This only applies to graph updates requested using the AstarPath.UpdateGraphs(Bounds,System.Single) method. Not those requested using AstarPath.RegisterSafeUpdate(System.Action) or AstarPath.AddWorkItem(System.Action) . See: graph-updates (view in online documentation for working links) Declaration public float graphUpdateBatchingInterval Field Value Type Description Single heuristic The distance function to use as a heuristic. The heuristic, often referred to as just 'H' is the estimated cost from a node to the target. Different heuristics affect how the path picks which one to follow from multiple possible with the same length See: Pathfinding.Heuristic for more details and descriptions of the different modes. See: Wikipedia: Admissible heuristic See: Wikipedia: A* search algorithm See: Wikipedia: Dijkstra's Algorithm Declaration public Heuristic heuristic Field Value Type Description Heuristic heuristicScale The scale of the heuristic. If a value lower than 1 is used, the pathfinder will search more nodes (slower). If 0 is used, the pathfinding algorithm will be reduced to dijkstra's algorithm. This is equivalent to setting AstarPath.heuristic to None. If a value larger than 1 is used the pathfinding will (usually) be faster because it expands fewer nodes, but the paths may no longer be the optimal (i.e the shortest possible paths). Usually you should leave this to the default value of 1. See: https://en.wikipedia.org/wiki/Admissible_heuristic See: https://en.wikipedia.org/wiki/A*_search_algorithm See: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm Declaration public float heuristicScale Field Value Type Description Single logPathResults The amount of debugging messages. Use less debugging to improve performance (a bit) or just to get rid of the Console spamming. Use more debugging (heavy) if you want more information about what the pathfinding scripts are doing. The InGame option will display the latest path log using in-game GUI. [Open online documentation to see images] Declaration public PathLog logPathResults Field Value Type Description PathLog manualDebugFloorRoof If set, the AstarPath.debugFloor and AstarPath.debugRoof values will not be automatically recalculated. Note: Only relevant in the editor Declaration public bool manualDebugFloorRoof Field Value Type Description Boolean maxFrameTime Max number of milliseconds to spend each frame for pathfinding. At least 500 nodes will be searched each frame (if there are that many to search). When using multithreading this value is irrelevant. Declaration public float maxFrameTime Field Value Type Description Single maxNearestNodeDistance @name Inspector - Settings @{ Declaration public float maxNearestNodeDistance Field Value Type Description Single navmeshUpdates Handles navmesh cuts. See: Declaration public readonly NavmeshUpdates navmeshUpdates Field Value Type Description NavmeshUpdates On65KOverflow Called when pathID overflows 65536 and resets back to zero. Note: This callback will be cleared every time it is called, so if you want to register to it repeatedly, register to it directly on receiving the callback as well. Declaration public static Action On65KOverflow Field Value Type Description Action OnAwakeSettings Declaration public static Action OnAwakeSettings Field Value Type Description Action OnGraphPostScan Called for each graph after they have been scanned. All other graphs might not have been scanned yet. Declaration public static OnGraphDelegate OnGraphPostScan Field Value Type Description OnGraphDelegate OnGraphPreScan Called for each graph before they are scanned Declaration public static OnGraphDelegate OnGraphPreScan Field Value Type Description OnGraphDelegate OnGraphsUpdated Called when any graphs are updated. Register to for example recalculate the path whenever a graph changes. Declaration public static OnScanDelegate OnGraphsUpdated Field Value Type Description OnScanDelegate OnGraphsWillBeUpdated Deprecated: Declaration [Obsolete] public Action OnGraphsWillBeUpdated Field Value Type Description Action OnGraphsWillBeUpdated2 Deprecated: Declaration [Obsolete] public Action OnGraphsWillBeUpdated2 Field Value Type Description Action OnLatePostScan Called after scanning has completed fully. This is called as the last thing in the Scan function. Declaration public static OnScanDelegate OnLatePostScan Field Value Type Description OnScanDelegate OnPathPostSearch Called for each path after searching. Be careful when using multithreading since this will be called from a different thread. Declaration public static OnPathDelegate OnPathPostSearch Field Value Type Description OnPathDelegate OnPathPreSearch Called for each path before searching. Be careful when using multithreading since this will be called from a different thread. Declaration public static OnPathDelegate OnPathPreSearch Field Value Type Description OnPathDelegate OnPostScan Called after scanning. This is called before applying links, flood-filling the graphs and other post processing. Declaration public static OnScanDelegate OnPostScan Field Value Type Description OnScanDelegate OnPreScan Called before starting the scanning Declaration public static OnScanDelegate OnPreScan Field Value Type Description OnScanDelegate prioritizeGraphs Prioritize graphs. Graphs will be prioritized based on their order in the inspector. The first graph which has a node closer than AstarPath.prioritizeGraphsLimit will be chosen instead of searching all graphs. Declaration public bool prioritizeGraphs Field Value Type Description Boolean prioritizeGraphsLimit Distance limit for AstarPath.prioritizeGraphs . See: AstarPath.prioritizeGraphs Declaration public float prioritizeGraphsLimit Field Value Type Description Single scanOnStartup If true, all graphs will be scanned during Awake. This does not include loading from the cache. If you disable this, you will have to call \\link Scan AstarPath.active.Scan() \\endlink yourself to enable pathfinding. Alternatively you could load a saved graph from a file. See: AstarPath.Scan(NavGraph) See: AstarPath.ScanAsync(NavGraph) Declaration public bool scanOnStartup Field Value Type Description Boolean showGraphs Shows or hides graph inspectors. Used internally by the editor Declaration public bool showGraphs Field Value Type Description Boolean showNavGraphs @name Inspector - Debug @{ Declaration public bool showNavGraphs Field Value Type Description Boolean showSearchTree If enabled, nodes will draw a line to their 'parent'. This will show the search tree for the latest path. Note: Only relevant in the editor TODO: Add a showOnlyLastPath flag to indicate whether to draw every node or only the ones visited by the latest path. Declaration public bool showSearchTree Field Value Type Description Boolean showUnwalkableNodes Toggle to show unwalkable nodes. Note: Only relevant in the editor See: AstarPath.unwalkableNodeDebugSize Declaration public bool showUnwalkableNodes Field Value Type Description Boolean tagNames Stored tag names. See: AstarPath.FindTagNames See: AstarPath.GetTagNames Declaration protected string[] tagNames Field Value Type Description String [] threadCount Number of pathfinding threads to use. Multithreading puts pathfinding in another thread, this is great for performance on 2+ core computers since the framerate will barely be affected by the pathfinding at all. None indicates that the pathfinding is run in the Unity thread as a coroutine Automatic will try to adjust the number of threads to the number of cores and memory on the computer. Less than 512mb of memory or a single core computer will make it revert to using no multithreading. It is recommended that you use one of the \"Auto\" settings that are available. The reason is that even if your computer might be beefy and have 8 cores. Other computers might only be quad core or dual core in which case they will not benefit from more than 1 or 3 threads respectively (you usually want to leave one core for the unity thread). If you use more threads than the number of cores on the computer it is mostly just wasting memory, it will not run any faster. The extra memory usage is not trivially small. Each thread needs to keep a small amount of data for each node in all the graphs. It is not the full graph data but it is proportional to the number of nodes. The automatic settings will inspect the machine it is running on and use that to determine the number of threads so that no memory is wasted. The exception is if you only have one (or maybe two characters) active at time. Then you should probably just go with one thread always since it is very unlikely that you will need the extra throughput given by more threads. Keep in mind that more threads primarily increases throughput by calculating different paths on different threads, it will not calculate individual paths any faster. Note that if you are modifying the pathfinding core scripts or if you are directly modifying graph data without using any of the safe wrappers (like AstarPath.AddWorkItem(System.Action) multithreading can cause strange errors and pathfinding stopping to work if you are not careful. For basic usage (not modding the pathfinding core) it should be safe. Note: WebGL does not support threads at all (since javascript is single-threaded) so no threads will be used on that platform. See: CalculateThreadCount Declaration public ThreadCount threadCount Field Value Type Description ThreadCount unwalkableNodeDebugSize Size of the red cubes shown in place of unwalkable nodes. Note: Only relevant in the editor. Does not apply to grid graphs. See: AstarPath.showUnwalkableNodes Declaration public float unwalkableNodeDebugSize Field Value Type Description Single Version The version number for the A* %Pathfinding Project Declaration public static readonly Version Version Field Value Type Description Version Properties astarData Holds all graph data. Deprecated: The 'astarData' field has been renamed to 'data' Declaration [Obsolete(\"The 'astarData' field has been renamed to 'data'\")] public AstarData astarData { get; } Property Value Type Description AstarData graphs Shortcut to Pathfinding.AstarData.graphs Declaration public NavGraph[] graphs { get; } Property Value Type Description NavGraph [] graphTypes See Pathfinding.AstarData Deprecated: Declaration [Obsolete] public Type[] graphTypes { get; } Property Value Type Description Type [] IsAnyGraphUpdateInProgress Returns if any graph updates are being calculated right now. Note: This does not includes other types of work items such as navmesh cutting or anything added by AstarPath.RegisterSafeUpdate(System.Action) or AstarPath.AddWorkItem(System.Action) . See: IsAnyWorkItemInProgress Declaration public bool IsAnyGraphUpdateInProgress { get; } Property Value Type Description Boolean IsAnyGraphUpdateQueued Returns if any graph updates are waiting to be applied. Note: This is false while the updates are being performed. Note: This does not includes other types of work items such as navmesh cutting or anything added by AstarPath.RegisterSafeUpdate(System.Action) or AstarPath.AddWorkItem(System.Action) . Declaration public bool IsAnyGraphUpdateQueued { get; } Property Value Type Description Boolean IsAnyGraphUpdatesQueued Returns if any graph updates are waiting to be applied. Deprecated: Use IsAnyGraphUpdateQueued instead Declaration [Obsolete(\"Fixed grammar, use IsAnyGraphUpdateQueued instead\")] public bool IsAnyGraphUpdatesQueued { get; } Property Value Type Description Boolean IsAnyWorkItemInProgress Returns if any work items are in progress right now. Note: This includes pretty much all types of graph updates. Such as normal graph updates, navmesh cutting and anything added by AstarPath.RegisterSafeUpdate(System.Action) or AstarPath.AddWorkItem(System.Action) . Declaration public bool IsAnyWorkItemInProgress { get; } Property Value Type Description Boolean isScanning Set while any graphs are being scanned. It will be true up until the FloodFill is done. Note: Not to be confused with graph updates. Used to better support Graph Update Objects called for example in OnPostScan See: IsAnyGraphUpdateQueued See: IsAnyGraphUpdateInProgress Declaration public bool isScanning { get; } Property Value Type Description Boolean IsUsingMultithreading Returns whether or not multithreading is used. \\exception System.Exception Is thrown when it could not be decided if multithreading was used or not. This should not happen if pathfinding is set up correctly. Note: This uses info about if threads are running right now, it does not use info from the settings on the A* object. Declaration public bool IsUsingMultithreading { get; } Property Value Type Description Boolean lastScanTime The time it took for the last call to Scan() to complete. Used to prevent automatically rescanning the graphs too often (editor only) Declaration public float lastScanTime { get; } Property Value Type Description Single limitGraphUpdates Batch graph updates. Deprecated: This field has been renamed to AstarPath.batchGraphUpdates . Declaration [Obsolete(\"This field has been renamed to 'batchGraphUpdates'\")] public bool limitGraphUpdates { get; set; } Property Value Type Description Boolean maxGraphUpdateFreq Limit for how often should graphs be updated. Deprecated: This field has been renamed to AstarPath.graphUpdateBatchingInterval . Declaration [Obsolete(\"This field has been renamed to 'graphUpdateBatchingInterval'\")] public float maxGraphUpdateFreq { get; set; } Property Value Type Description Single maxNearestNodeDistanceSqr Max Nearest Node Distance Squared. See: AstarPath.maxNearestNodeDistance Declaration public float maxNearestNodeDistanceSqr { get; } Property Value Type Description Single NumParallelThreads Number of parallel pathfinders. Returns the number of concurrent processes which can calculate paths at once. When using multithreading, this will be the number of threads, if not using multithreading it is always 1 (since only 1 coroutine is used). See: IsUsingMultithreading Declaration public int NumParallelThreads { get; } Property Value Type Description Int32 Methods AddWorkItem(AstarWorkItem) Add a work item to be processed when pathfinding is paused. The work item will be executed when it is safe to update nodes. This is defined as between the path searches. When using more threads than one, calling this often might decrease pathfinding performance due to a lot of idling in the threads. Not performance as in it will use much CPU power, but performance as in the number of paths per second will probably go down (though your framerate might actually increase a tiny bit). You should only call this function from the main unity thread (i.e normal game code). AstarPath.active.AddWorkItem(new AstarWorkItem(() => { // Safe to update graphs here var node = AstarPath.active.GetNearest(transform.position).node; node.Walkable = false; })); AstarPath.active.AddWorkItem(() => { // Safe to update graphs here var node = AstarPath.active.GetNearest(transform.position).node; node.position = (Int3)transform.position; }); See: AstarPath.FlushWorkItems Declaration public void AddWorkItem(AstarWorkItem item) Parameters Type Name Description AstarWorkItem item AddWorkItem(Action) Add a work item to be processed when pathfinding is paused. Convenience method that is equivalent to AddWorkItem(new AstarWorkItem(callback)); See: AstarPath.AddWorkItem(AstarWorkItem) Declaration public void AddWorkItem(Action callback) Parameters Type Name Description Action callback AddWorkItem(Action<IWorkItemContext>) Add a work item to be processed when pathfinding is paused. Convenience method that is equivalent to AddWorkItem(new AstarWorkItem(callback)); See: AstarPath.AddWorkItem(AstarWorkItem) Declaration public void AddWorkItem(Action<IWorkItemContext> callback) Parameters Type Name Description Action < IWorkItemContext > callback Awake() Sets up all needed variables and scans the graphs. Calls Initialize, starts the ReturnPaths coroutine and scans all graphs. Also starts threads if using multithreading See: AstarPath.OnAwakeSettings Declaration protected override void Awake() BlockUntilCalculated(Path) Blocks until the path has been calculated. Normally it takes a few frames for a path to be calculated and returned. This function will ensure that the path will be calculated when this function returns and that the callback for that path has been called. If requesting a lot of paths in one go and waiting for the last one to complete, it will calculate most of the paths in the queue (only most if using multithreading, all if not using multithreading). Use this function only if you really need to. There is a point to spreading path calculations out over several frames. It smoothes out the framerate and makes sure requesting a large number of paths at the same time does not cause lag. Note: Graph updates and other callbacks might get called during the execution of this function. When the pathfinder is shutting down. I.e in OnDestroy, this function will not do anything. \\throws Exception if pathfinding is not initialized properly for this scene (most likely no AstarPath object exists) or if the path has not been started yet. Also throws an exception if critical errors occur such as when the pathfinding threads have crashed (which should not happen in normal cases). This prevents an infinite loop while waiting for the path. See: Pathfinding.Path.WaitForPath See: Pathfinding.Path.BlockUntilCalculated Declaration public static void BlockUntilCalculated(Path path) Parameters Type Name Description Path path The path to wait for. The path must be started, otherwise an exception will be thrown. BlockUntilPathQueueBlocked() Blocks until all pathfinding threads are paused and blocked. Deprecated: Use AstarPath.PausePathfinding instead. Make sure to call Release on the returned lock. Declaration [Obsolete(\"Use PausePathfinding instead. Make sure to call Release on the returned lock.\", true)] public void BlockUntilPathQueueBlocked() CalculateThreadCount(ThreadCount) Declaration public static int CalculateThreadCount(ThreadCount count) Parameters Type Name Description ThreadCount count Returns Type Description Int32 ConfigureReferencesInternal() \\cond internal Declaration public void ConfigureReferencesInternal() EnsureValidFloodFill() If a WorkItem needs to have a valid flood fill during execution, call this method to ensure there are no pending flood fills. Deprecated: This method has been moved. Use the method on the context object that can be sent with work item delegates instead AstarPath.active.AddWorkItem(new AstarWorkItem(() => { // Safe to update graphs here var node = AstarPath.active.GetNearest(transform.position).node; node.Walkable = false; })); See: Pathfinding.IWorkItemContext Declaration [Obsolete(\"This method has been moved. Use the method on the context object that can be sent with work item delegates instead\")] public void EnsureValidFloodFill() FindAstarPath() Used outside of play mode to initialize the AstarPath object even if it has not been selected in the inspector yet. This will set the AstarPath.active property and deserialize all graphs. This is useful if you want to do changes to the graphs in the editor outside of play mode, but cannot be sure that the graphs have been deserialized yet. In play mode this method does nothing. Declaration public static void FindAstarPath() FindTagNames() Tries to find an AstarPath object and return tag names. If an AstarPath object cannot be found, it returns an array of length 1 with an error message. See: AstarPath.GetTagNames Declaration public static string[] FindTagNames() Returns Type Description String [] FloodFill() Floodfills all graphs and updates areas for every node. The different colored areas that you see in the scene view when looking at graphs are called just 'areas', this method calculates which nodes are in what areas. See: Pathfinding.Node.area Deprecated: Avoid using. This will force a full recalculation of the connected components. In most cases the HierarchicalGraph class takes care of things automatically behind the scenes now. Declaration [Obsolete(\"Avoid using. This will force a full recalculation of the connected components. In most cases the HierarchicalGraph class takes care of things automatically behind the scenes now.\")] public void FloodFill() FloodFill(GraphNode) Floodfills starting from the specified node. Deprecated: Deprecated: Not meaningful anymore. The HierarchicalGraph takes care of things automatically behind the scenes Declaration [Obsolete(\"Not meaningful anymore. The HierarchicalGraph takes care of things automatically behind the scenes\")] public void FloodFill(GraphNode seed) Parameters Type Name Description GraphNode seed FloodFill(GraphNode, UInt32) Floodfills starting from 'seed' using the specified area. Deprecated: Not meaningful anymore. The HierarchicalGraph takes care of things automatically behind the scenes Declaration [Obsolete(\"Not meaningful anymore. The HierarchicalGraph takes care of things automatically behind the scenes\")] public void FloodFill(GraphNode seed, uint area) Parameters Type Name Description GraphNode seed UInt32 area FlushGraphUpdates() Forces graph updates to complete in a single frame. This will force the pathfinding threads to finish calculating the path they are currently calculating (if any) and then pause. When all threads have paused, graph updates will be performed. Warning: Using this very often (many times per second) can reduce your fps due to a lot of threads waiting for one another. But you probably wont have to worry about that. Note: This is almost identical to AstarPath.FlushWorkItems , but added for more descriptive name. This function will also override any time limit delays for graph updates. This is because graph updates are implemented using work items. So calling this function will also execute any other work items (if any are queued). Will not do anything if there are no graph updates queued (not even execute other work items). Declaration public void FlushGraphUpdates() FlushThreadSafeCallbacks() Forces thread safe callbacks to run. Deprecated: Use AstarPath.FlushWorkItems instead Declaration [Obsolete(\"Use FlushWorkItems instead\")] public void FlushThreadSafeCallbacks() FlushWorkItems() Forces work items to complete in a single frame. This will force all work items to run immidiately. This will force the pathfinding threads to finish calculating the path they are currently calculating (if any) and then pause. When all threads have paused, work items will be executed (which can be e.g graph updates). Warning: Using this very often (many times per second) can reduce your fps due to a lot of threads waiting for one another. But you probably wont have to worry about that Note: This is almost (note almost) identical to AstarPath.FlushGraphUpdates , but added for more descriptive name. Will not do anything if there are no queued work items waiting to run. Declaration public void FlushWorkItems() FlushWorkItems(Boolean, Boolean) Make sure work items are executed. See: AddWorkItem Deprecated: Use AstarPath.FlushWorkItems instead. Declaration [Obsolete(\"Use FlushWorkItems() instead\")] public void FlushWorkItems(bool unblockOnComplete, bool block) Parameters Type Name Description Boolean unblockOnComplete If true, pathfinding will be allowed to start running immediately after completing all work items. Boolean block If true, work items that usually take more than one frame to complete will be forced to complete during this call. If false, then after this call there might still be work left to do. GetNearest(Ray) Returns the node closest to the ray (slow). Warning: This function is brute-force and very slow, use with caution Declaration public GraphNode GetNearest(Ray ray) Parameters Type Name Description Ray ray Returns Type Description GraphNode GetNearest(Vector3) Returns the nearest node to a position using the specified NNConstraint. Searches through all graphs for their nearest nodes to the specified position and picks the closest one.\\n Using the NNConstraint.None constraint. // Find the closest node to this GameObject's position GraphNode node = AstarPath.active.GetNearest(transform.position).node; if (node.Walkable) { // Yay, the node is walkable, we can place a tower here or something } See: Pathfinding.NNConstraint Declaration public NNInfo GetNearest(Vector3 position) Parameters Type Name Description Vector3 position Returns Type Description NNInfo GetNearest(Vector3, NNConstraint) Declaration public NNInfo GetNearest(Vector3 position, NNConstraint constraint) Parameters Type Name Description Vector3 position NNConstraint constraint Returns Type Description NNInfo GetNearest(Vector3, NNConstraint, GraphNode) Returns the nearest node to a position using the specified NNConstraint. Searches through all graphs for their nearest nodes to the specified position and picks the closest one. The NNConstraint can be used to specify constraints on which nodes can be chosen such as only picking walkable nodes. See: Pathfinding.NNConstraint Declaration public NNInfo GetNearest(Vector3 position, NNConstraint constraint, GraphNode hint) Parameters Type Name Description Vector3 position NNConstraint constraint GraphNode hint Returns Type Description NNInfo GetTagNames() Returns tag names. Makes sure that the tag names array is not null and of length 32. If it is null or not of length 32, it creates a new array and fills it with 0,1,2,3,4 etc... See: AstarPath.FindTagNames Declaration public string[] GetTagNames() Returns Type Description String [] PausePathfinding() Blocks until all pathfinding threads are paused and blocked. var graphLock = AstarPath.active.PausePathfinding(); // Here we can modify the graphs safely. For example by adding a new node to a point graph var node = AstarPath.active.data.pointGraph.AddNode((Int3) new Vector3(3, 1, 4)); // Allow pathfinding to resume graphLock.Release(); Returns: A lock object. You need to call Pathfinding.PathProcessor.GraphUpdateLock.Release on that object to allow pathfinding to resume. Note: In most cases this should not be called from user code. Use the AstarPath.AddWorkItem(System.Action) method instead. See: AstarPath.AddWorkItem(System.Action) Declaration public PathProcessor.GraphUpdateLock PausePathfinding() Returns Type Description PathProcessor.GraphUpdateLock QueueGraphUpdates() Will apply queued graph updates as soon as possible, regardless of AstarPath.batchGraphUpdates . Calling this multiple times will not create multiple callbacks. This function is useful if you are limiting graph updates, but you want a specific graph update to be applied as soon as possible regardless of the time limit. Note that this does not block until the updates are done, it merely bypasses the AstarPath.batchGraphUpdates time limit. See: AstarPath.FlushGraphUpdates Declaration public void QueueGraphUpdates() QueueWorkItemFloodFill() Call during work items to queue a flood fill. Deprecated: This method has been moved. Use the method on the context object that can be sent with work item delegates instead AstarPath.active.AddWorkItem(new AstarWorkItem(() => { // Safe to update graphs here var node = AstarPath.active.GetNearest(transform.position).node; node.Walkable = false; })); See: Pathfinding.IWorkItemContext Declaration [Obsolete(\"This method has been moved. Use the method on the context object that can be sent with work item delegates instead\")] public void QueueWorkItemFloodFill() RegisterSafeUpdate(Action) Will send a callback when it is safe to update nodes. This is defined as between the path searches. This callback will only be sent once and is nulled directly after the callback has been sent. When using more threads than one, calling this often might decrease pathfinding performance due to a lot of idling in the threads. Not performance as in it will use much CPU power, but performance as in the number of paths per second will probably go down (though your framerate might actually increase a tiny bit) You should only call this function from the main unity thread (i.e normal game code). Version: Since version 4.0 this is equivalent to AddWorkItem(new AstarWorkItem(callback)). Previously the callbacks added using this method would not be ordered with respect to other work items, so they could be executed before other work items or after them. Deprecated: Use AstarPath.AddWorkItem(System.Action) instead. Note the slight change in behavior (mentioned above). Declaration [Obsolete(\"Use AddWorkItem(System.Action) instead. Note the slight change in behavior (mentioned in the documentation).\")] public static void RegisterSafeUpdate(Action callback) Parameters Type Name Description Action callback Scan(NavGraph) Scans a particular graph. Calling this method will recalculate the specified graph. This method is pretty slow (depending on graph type and graph complexity of course), so it is advisable to use smaller graph updates whenever possible. // Recalculate all graphs AstarPath.active.Scan(); // Recalculate only the first grid graph var graphToScan = AstarPath.active.data.gridGraph; AstarPath.active.Scan(graphToScan); // Recalculate only the first and third graphs var graphsToScan = new [] { AstarPath.active.data.graphs[0], AstarPath.active.data.graphs[2] }; AstarPath.active.Scan(graphsToScan); See: graph-updates (view in online documentation for working links) See: ScanAsync Declaration public void Scan(NavGraph graphToScan) Parameters Type Name Description NavGraph graphToScan Scan(NavGraph[]) Scans all specified graphs. Calling this method will recalculate all specified graphs or all graphs if the graphsToScan parameter is null. This method is pretty slow (depending on graph type and graph complexity of course), so it is advisable to use smaller graph updates whenever possible. // Recalculate all graphs AstarPath.active.Scan(); // Recalculate only the first grid graph var graphToScan = AstarPath.active.data.gridGraph; AstarPath.active.Scan(graphToScan); // Recalculate only the first and third graphs var graphsToScan = new [] { AstarPath.active.data.graphs[0], AstarPath.active.data.graphs[2] }; AstarPath.active.Scan(graphsToScan); See: graph-updates (view in online documentation for working links) See: ScanAsync Declaration public void Scan(NavGraph[] graphsToScan = null) Parameters Type Name Description NavGraph [] graphsToScan The graphs to scan. If this parameter is null then all graphs will be scanned ScanAsync(NavGraph) Scans a particular graph asynchronously. This is a IEnumerable, you can loop through it to get the progress foreach (Progress progress in AstarPath.active.ScanAsync()) { Debug.Log(\"Scanning... \" + progress.description + \" - \" + (progress.progress*100).ToString(\"0\") + \"%\"); } You can scan graphs asyncronously by yielding when you loop through the progress. Note that this does not guarantee a good framerate, but it will allow you to at least show a progress bar during scanning. IEnumerator Start () { foreach (Progress progress in AstarPath.active.ScanAsync()) { Debug.Log(\"Scanning... \" + progress.description + \" - \" + (progress.progress*100).ToString(\"0\") + \"%\"); yield return null; } } See: Scan Declaration public IEnumerable<Progress> ScanAsync(NavGraph graphToScan) Parameters Type Name Description NavGraph graphToScan Returns Type Description System.Collections.IEnumerable < Progress > ScanAsync(NavGraph[]) Scans all specified graphs asynchronously. This is a IEnumerable, you can loop through it to get the progress foreach (Progress progress in AstarPath.active.ScanAsync()) { Debug.Log(\"Scanning... \" + progress.description + \" - \" + (progress.progress*100).ToString(\"0\") + \"%\"); } You can scan graphs asyncronously by yielding when you loop through the progress. Note that this does not guarantee a good framerate, but it will allow you to at least show a progress bar during scanning. IEnumerator Start () { foreach (Progress progress in AstarPath.active.ScanAsync()) { Debug.Log(\"Scanning... \" + progress.description + \" - \" + (progress.progress*100).ToString(\"0\") + \"%\"); yield return null; } } See: Scan Declaration public IEnumerable<Progress> ScanAsync(NavGraph[] graphsToScan = null) Parameters Type Name Description NavGraph [] graphsToScan The graphs to scan. If this parameter is null then all graphs will be scanned Returns Type Description System.Collections.IEnumerable < Progress > StartPath(Path, Boolean) Adds the path to a queue so that it will be calculated as soon as possible. The callback specified when constructing the path will be called when the path has been calculated. Usually you should use the Seeker component instead of calling this function directly. Declaration public static void StartPath(Path path, bool pushToFront = false) Parameters Type Name Description Path path The path that should be enqueued. Boolean pushToFront If true, the path will be pushed to the front of the queue, bypassing all waiting paths and making it the next path to be calculated. This can be useful if you have a path which you want to prioritize over all others. Be careful to not overuse it though. If too many paths are put in the front of the queue often, this can lead to normal paths having to wait a very long time before being calculated. UpdateGraphs(Bounds) Update all graphs within bounds. The graphs will be updated as soon as possible. This is equivalent to UpdateGraphs(new GraphUpdateObject(bounds)); See: FlushGraphUpdates See: batchGraphUpdates See: graph-updates (view in online documentation for working links) Declaration public void UpdateGraphs(Bounds bounds) Parameters Type Name Description Bounds bounds UpdateGraphs(Bounds, Single) Update all graphs within bounds after delay seconds. The graphs will be updated as soon as possible. See: FlushGraphUpdates See: batchGraphUpdates See: graph-updates (view in online documentation for working links) Declaration public void UpdateGraphs(Bounds bounds, float delay) Parameters Type Name Description Bounds bounds Single delay UpdateGraphs(GraphUpdateObject) Update all graphs using the GraphUpdateObject. This can be used to, e.g make all nodes in a region unwalkable, or set them to a higher penalty. The graphs will be updated as soon as possible (with respect to AstarPath.batchGraphUpdates See: FlushGraphUpdates See: batchGraphUpdates See: graph-updates (view in online documentation for working links) Declaration public void UpdateGraphs(GraphUpdateObject ob) Parameters Type Name Description GraphUpdateObject ob UpdateGraphs(GraphUpdateObject, Single) Update all graphs using the GraphUpdateObject after delay seconds. This can be used to, e.g make all nodes in a region unwalkable, or set them to a higher penalty. See: FlushGraphUpdates See: batchGraphUpdates See: graph-updates (view in online documentation for working links) Declaration public void UpdateGraphs(GraphUpdateObject ob, float delay) Parameters Type Name Description GraphUpdateObject ob Single delay WaitForPath(Path) Wait for the specified path to be calculated. Normally it takes a few frames for a path to get calculated and returned. Deprecated: This method has been renamed to AstarPath.BlockUntilCalculated(Path) . Declaration [Obsolete(\"This method has been renamed to BlockUntilCalculated\")] public static void WaitForPath(Path path) Parameters Type Name Description Path path"
  },
  "api/Global.AttackableAttacker.html": {
    "href": "api/Global.AttackableAttacker.html",
    "title": "Class AttackableAttacker | Morpy",
    "keywords": "Class AttackableAttacker This component can be added to all objects that can attack others and that can be attacked by others Other components need to activate the \"attackNearest\" Method in this class in order for this attack to attack. Inheritance Object AttackableAttacker Namespace : Global Assembly : cs.temp.dll.dll Syntax public class AttackableAttacker : MonoBehaviour Fields attackButton Attack Button that should be greyed out during cooldown. If no button is provided, this will be ignored Declaration public GameObject attackButton Field Value Type Description GameObject attackRange Range this object can use to attack other objects Declaration public float attackRange Field Value Type Description Single cooldownTimeInSeconds Time the cooldown needs to complete in seconds. By default, an attacker has a cooldown of 1 second before they can attack again Declaration public float cooldownTimeInSeconds Field Value Type Description Single enemyAttackDelay Delay the enemies use while attacking Declaration public float enemyAttackDelay Field Value Type Description Single mass Define the character mass needed for calculating knockback forces Declaration public float mass Field Value Type Description Single nearAttackRange Range for near attacks Declaration public float nearAttackRange Field Value Type Description Single Methods attack(GameObject) Try to attack a specific GameObject on the map. Declaration public void attack(GameObject go) Parameters Type Name Description GameObject go GameObject to attack attackNearest() Attack the nearest enemy to this object using the standard attack Declaration public void attackNearest() attackNearestWithCustomAction() Attack the nearest enemy with our current special action Declaration public void attackNearestWithCustomAction() attackWithCustomAction(GameObject) Try to attack a specific GameObject with our special custom action Declaration public void attackWithCustomAction(GameObject go) Parameters Type Name Description GameObject go GameObject to attack calculateDistanceToObject(GameObject) Calculate the distance from the current object to another GameObject Declaration public float calculateDistanceToObject(GameObject go) Parameters Type Name Description GameObject go GameObject to calculate the distance to Returns Type Description Single Distance getAttacked(GameObject, Int32) Let this object get attacked by another object This method is mostly called by other AttackableAttacker components to attack each other Declaration public void getAttacked(GameObject attacker, int strength) Parameters Type Name Description GameObject attacker Attacker Object that attacked us Int32 strength Strength of the attack getEnemyTag() Get the tag for our enemy, who we should attack For the player, these will be the \"Enemy\" objects For enemies this will be the player Declaration public string getEnemyTag() Returns Type Description String Unity Tag String \"Player\" or \"Enemy\" getIsInCooldown() Get if the current object is in a cooldown Declaration public bool getIsInCooldown() Returns Type Description Boolean True if in cooldown getNearestEnemy() Get the Game object for our nearest enemy This will return \"null\" if no enemy exists Declaration public GameObject getNearestEnemy() Returns Type Description GameObject GameObject or null"
  },
  "api/Global.AttackEntersLeavesCooldown.html": {
    "href": "api/Global.AttackEntersLeavesCooldown.html",
    "title": "Class AttackEntersLeavesCooldown | Morpy",
    "keywords": "Class AttackEntersLeavesCooldown Event which is executed, when the Attacker enters or leave a cooldown Inheritance Object EventManager.Event EventManager.Event < AttackEntersLeavesCooldown > AttackEntersLeavesCooldown Inherited Members EventManager.Event<AttackEntersLeavesCooldown>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class AttackEntersLeavesCooldown : EventManager.Event<AttackEntersLeavesCooldown>, IComparable<EventManager.Event> Fields attackButton Declaration public GameObject attackButton Field Value Type Description GameObject isInCooldown Declaration public bool isInCooldown Field Value Type Description Boolean Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.AudioManager.html": {
    "href": "api/Global.AudioManager.html",
    "title": "Class AudioManager | Morpy",
    "keywords": "Class AudioManager AudioManager that handles playing audio in levels and the main menu Source: https://www.youtube.com/watch?v=6OT43pvUyfY Inheritance Object AudioManager Namespace : Global Assembly : cs.temp.dll.dll Syntax public class AudioManager : MonoBehaviour Fields instance Current AudioManager interface. Needed to enforce singeton behaviour Declaration public static AudioManager instance Field Value Type Description AudioManager mixerGroup Unity Audio Mixer Group Declaration public AudioMixerGroup mixerGroup Field Value Type Description AudioMixerGroup sounds A list of sounds that can be played during the game Declaration public Sound[] sounds Field Value Type Description Sound [] Methods Play(String) Play a sound using the AudioManager Declaration public void Play(string sound) Parameters Type Name Description String sound Name of the sound as defined in the Sounds array"
  },
  "api/Global.CameraController.html": {
    "href": "api/Global.CameraController.html",
    "title": "Class CameraController | Morpy",
    "keywords": "Class CameraController Inheritance Object CameraController Namespace : Global Assembly : cs.temp.dll.dll Syntax public class CameraController : MonoBehaviour Fields Direction defines the roate rirection Declaration public RoateDirection Direction Field Value Type Description RoateDirection rotate Indicates if camera should rotating Declaration public bool rotate Field Value Type Description Boolean virtualCamera the virtualCamera object Declaration public Cinemachine.CinemachineVirtualCamera virtualCamera Field Value Type Description Cinemachine.CinemachineVirtualCamera"
  },
  "api/Global.CharacterType.html": {
    "href": "api/Global.CharacterType.html",
    "title": "Enum CharacterType | Morpy",
    "keywords": "Enum CharacterType Defines all available charakter types Namespace : Global Assembly : cs.temp.dll.dll Syntax public enum CharacterType Fields Name Description Bee Bunny NotSpecified Rhino Slime Snail"
  },
  "api/Global.DeathZone.html": {
    "href": "api/Global.DeathZone.html",
    "title": "Class DeathZone | Morpy",
    "keywords": "Class DeathZone Defines a Zone in which the player should immediately die, when he enters the zone Inheritance Object DeathZone Namespace : Global Assembly : cs.temp.dll.dll Syntax public class DeathZone : MonoBehaviour"
  },
  "api/Global.EnablePlayerInput.html": {
    "href": "api/Global.EnablePlayerInput.html",
    "title": "Class EnablePlayerInput | Morpy",
    "keywords": "Class EnablePlayerInput Event which enabled the input of the player Inheritance Object EventManager.Event EventManager.Event < EnablePlayerInput > EnablePlayerInput Inherited Members EventManager.Event<EnablePlayerInput>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class EnablePlayerInput : EventManager.Event<EnablePlayerInput>, IComparable<EventManager.Event> Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.EnemyAI.html": {
    "href": "api/Global.EnemyAI.html",
    "title": "Class EnemyAI | Morpy",
    "keywords": "Class EnemyAI Class defining the behaviour of hostile entities Inheritance Object EnemyAI Namespace : Global Assembly : cs.temp.dll.dll Syntax public class EnemyAI : MonoBehaviour Fields activateDistance Defines how far the player has to be away for the character to start moving. Declaration public float activateDistance Field Value Type Description Single animator The animation object which is used to animate the character. Declaration public Animator animator Field Value Type Description Animator bunnySpecialAttackDelay Declaration public float bunnySpecialAttackDelay Field Value Type Description Single characterType Defines what kind of character the AI has. Declaration public CharacterType characterType Field Value Type Description CharacterType directionLookEnabled Defines if the charakter looks into the direction it is going into. Declaration public bool directionLookEnabled Field Value Type Description Boolean followEnabled The layer on which the playes is on. Declaration public bool followEnabled Field Value Type Description Boolean gravityDown Defines if the character should walk on the flor or the ceiling. Declaration public bool gravityDown Field Value Type Description Boolean jumpCheckOffset Defines a little bit of wiggle-room to decide if the character touches the ground or not. Declaration public float jumpCheckOffset Field Value Type Description Single jumpEnabled Defines if the charakter is able to jump. Declaration public bool jumpEnabled Field Value Type Description Boolean jumpModifier Defines the multiplier that gets applied into the y-direction if a charakter jumps. Declaration public float jumpModifier Field Value Type Description Single jumpNodeHeightRequirement Defines at which height-differenc of the path the charakter should attempt jumping. Declaration public float jumpNodeHeightRequirement Field Value Type Description Single nextWaypointDistance Defines at which point a new Waypoint should be used to follow the path. Declaration public float nextWaypointDistance Field Value Type Description Single pathUpdateSeconds Defines how often the path should be recalculated. Declaration public float pathUpdateSeconds Field Value Type Description Single platformLayerMask The layer on which the charakter should move on. Declaration public LayerMask platformLayerMask Field Value Type Description LayerMask playerLayerMask Declaration public LayerMask playerLayerMask Field Value Type Description LayerMask speed Declaration public float speed Field Value Type Description Single target Declaration public Transform target Field Value Type Description Transform Methods Jump() Makes the charakter jump by applying an upwards force. Declaration public void Jump() Run() Makes a charakter run by multiplying its force in the x-direction. Declaration public void Run() Start() Initializes AI by getting all necessary components, turning the gravity if nexessary and starting to compute paths. Declaration public void Start()"
  },
  "api/Global.EnemyAI.MovementState.html": {
    "href": "api/Global.EnemyAI.MovementState.html",
    "title": "Enum EnemyAI.MovementState | Morpy",
    "keywords": "Enum EnemyAI.MovementState The different kind of states of movement a charakter can be in. Namespace : Global Assembly : cs.temp.dll.dll Syntax public enum MovementState Fields Name Description Sprinting Standing Walking"
  },
  "api/Global.EnemyArtifact.html": {
    "href": "api/Global.EnemyArtifact.html",
    "title": "Class EnemyArtifact | Morpy",
    "keywords": "Class EnemyArtifact This class only contains the charakter type of a artifact, which has been dropped by a dead enemy Inheritance Object EnemyArtifact Namespace : Global Assembly : cs.temp.dll.dll Syntax public class EnemyArtifact : MonoBehaviour Fields characterType Declaration public CharacterType characterType Field Value Type Description CharacterType"
  },
  "api/Global.EnemyArtifactSpawner.html": {
    "href": "api/Global.EnemyArtifactSpawner.html",
    "title": "Class EnemyArtifactSpawner | Morpy",
    "keywords": "Class EnemyArtifactSpawner Artifact Spawner, which contains all artifacts of dead enemys Inheritance Object EnemyArtifactSpawner Namespace : Global Assembly : cs.temp.dll.dll Syntax public class EnemyArtifactSpawner : MonoBehaviour Fields enemyBunnyArtifactPrefab bunny artifact prefab Declaration public Transform enemyBunnyArtifactPrefab Field Value Type Description Transform enemyRhinoArtifactPrefab rhino artifact prefab Declaration public Transform enemyRhinoArtifactPrefab Field Value Type Description Transform enemySlimeArtifactPrefab slime artifact prefab Declaration public Transform enemySlimeArtifactPrefab Field Value Type Description Transform Methods SpawnArtifact(CharacterType, Vector3) Instantiate an Artifact on the position where a enemy has died. The artifact contains the character type information of the dead enemy Declaration public void SpawnArtifact(CharacterType characterType, Vector3 position) Parameters Type Name Description CharacterType characterType character type of the dead enemy Vector3 position Position of the dead enemy"
  },
  "api/Global.EnemyDeath.html": {
    "href": "api/Global.EnemyDeath.html",
    "title": "Class EnemyDeath | Morpy",
    "keywords": "Class EnemyDeath Event which disable the enemy gameobject and spawns a new artifact Inheritance Object EventManager.Event EventManager.Event < HealthIsZero > EnemyDeath Inherited Members EventManager.Event<HealthIsZero>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class EnemyDeath : EventManager.Event<HealthIsZero>, IComparable<EventManager.Event> Fields gameObject Declaration public GameObject gameObject Field Value Type Description GameObject Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.EventManager.Event.html": {
    "href": "api/Global.EventManager.Event.html",
    "title": "Class EventManager.Event | Morpy",
    "keywords": "Class EventManager.Event An event is something that happens at a point in time in a simulation. Inheritance Object EventManager.Event EventManager.Event<T> Namespace : Global Assembly : cs.temp.dll.dll Syntax public abstract class Event : IComparable<EventManager.Event> Methods CompareTo(EventManager.Event) Declaration public int CompareTo(EventManager.Event other) Parameters Type Name Description EventManager.Event other Returns Type Description Int32 Execute() The Acton which will be executes when the event is happening Declaration public abstract void Execute() Precondition() Declaration public virtual bool Precondition() Returns Type Description Boolean"
  },
  "api/Global.EventManager.Event-1.html": {
    "href": "api/Global.EventManager.Event-1.html",
    "title": "Class EventManager.Event<T> | Morpy",
    "keywords": "Class EventManager.Event<T> Event adds the ability to hook into the OnExecute callback whenever the event is executed. Inheritance Object EventManager.Event EventManager.Event<T> AttackEntersLeavesCooldown EnablePlayerInput EnemyDeath HealthIsZero LoadLevel MorphPlayer PlayerDeath PlayerEnteredDeathZone PlayerEnteredGoal PlayerSpawn RotateWorld Inherited Members EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Execute() EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public abstract class Event<T> : EventManager.Event, IComparable<EventManager.Event> where T : EventManager.Event<T> Type Parameters Name Description T Fields OnExecute Declaration public static Action<T> OnExecute Field Value Type Description Action <T>"
  },
  "api/Global.EventManager.html": {
    "href": "api/Global.EventManager.html",
    "title": "Class EventManager | Morpy",
    "keywords": "Class EventManager Events are pooled, with a default capacity of 4 instances. Inheritance Object EventManager Namespace : Global Assembly : cs.temp.dll.dll Syntax public static class EventManager Methods Clear() Clear all pending events and reset the tick to 0. Declaration public static void Clear() DestroyModel<T>() Destroy the simulation model instance for a class. Declaration public static void DestroyModel<T>() where T : class, new() Type Parameters Name Description T GetModel<T>() Return the simulation model instance for a class. Declaration public static T GetModel<T>() where T : class, new() Returns Type Description T Type Parameters Name Description T New<T>() Create a new event of type T and return it. Declaration public static T New<T>() where T : EventManager.Event, new() Returns Type Description T Type Parameters Name Description T Reschedule<T>(T, Single) Reschedule an existing event for a future tick, and return it. Declaration public static T Reschedule<T>(T ev, float tick) where T : EventManager.Event, new() Parameters Type Name Description T ev Single tick Tick. Returns Type Description T The event. Type Parameters Name Description T The event type parameter. Schedule<T>(Single) Schedule an event for a future tick, and return it. Declaration public static T Schedule<T>(float tick = 0F) where T : EventManager.Event, new() Parameters Type Name Description Single tick Returns Type Description T The event Type Parameters Name Description T The event type parameter. SetModel<T>(T) Set a simulation model instance for a class. Declaration public static void SetModel<T>(T instance) where T : class, new() Parameters Type Name Description T instance Type Parameters Name Description T Tick() Tick the simulation. Returns the count of remaining events. Declaration public static int Tick() Returns Type Description Int32"
  },
  "api/Global.GameController.html": {
    "href": "api/Global.GameController.html",
    "title": "Class GameController | Morpy",
    "keywords": "Class GameController Basic game controller with contains the platformer model Inheritance Object GameController Namespace : Global Assembly : cs.temp.dll.dll Syntax public class GameController : MonoBehaviour Fields model Declaration public PlatformerModel model Field Value Type Description PlatformerModel Properties Instance Declaration public static GameController Instance { get; } Property Value Type Description GameController"
  },
  "api/Global.GoalZone.html": {
    "href": "api/Global.GoalZone.html",
    "title": "Class GoalZone | Morpy",
    "keywords": "Class GoalZone Defines a Zone in which the player conpleted the level Inheritance Object GoalZone Namespace : Global Assembly : cs.temp.dll.dll Syntax public class GoalZone : MonoBehaviour"
  },
  "api/Global.Health.html": {
    "href": "api/Global.Health.html",
    "title": "Class Health | Morpy",
    "keywords": "Class Health Basic health controller for the player and the enemies. Inheritance Object Health Namespace : Global Assembly : cs.temp.dll.dll Syntax public class Health : MonoBehaviour Fields currentHp Declaration public int currentHp Field Value Type Description Int32 healthBarPrefab Declaration public GameObject healthBarPrefab Field Value Type Description GameObject maxHP Declaration public int maxHP Field Value Type Description Int32 Properties IsAlive Declaration public bool IsAlive { get; } Property Value Type Description Boolean Methods Decrement(Int32) Decrement the current health and update the healthbar Declaration public void Decrement(int amount = 1) Parameters Type Name Description Int32 amount Die() Decrement the current health points to zero Declaration public void Die() Increment(Int32) Increment the current health and update the healthbar Declaration public void Increment(int amount = 1) Parameters Type Name Description Int32 amount SetMaxHealth() Set the current health points to max Declaration public void SetMaxHealth()"
  },
  "api/Global.HealthBarController.html": {
    "href": "api/Global.HealthBarController.html",
    "title": "Class HealthBarController | Morpy",
    "keywords": "Class HealthBarController Inheritance Object HealthBarController Namespace : Global Assembly : cs.temp.dll.dll Syntax public class HealthBarController : MonoBehaviour"
  },
  "api/Global.HealthIsZero.html": {
    "href": "api/Global.HealthIsZero.html",
    "title": "Class HealthIsZero | Morpy",
    "keywords": "Class HealthIsZero Event which manages the case, when a player or a enemy has no health points Inheritance Object EventManager.Event EventManager.Event < HealthIsZero > HealthIsZero Inherited Members EventManager.Event<HealthIsZero>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class HealthIsZero : EventManager.Event<HealthIsZero>, IComparable<EventManager.Event> Fields gameObject Declaration public GameObject gameObject Field Value Type Description GameObject Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.HeapQueue-1.html": {
    "href": "api/Global.HeapQueue-1.html",
    "title": "Class HeapQueue<T> | Morpy",
    "keywords": "Class HeapQueue<T> Inheritance Object HeapQueue<T> Namespace : Global Assembly : cs.temp.dll.dll Syntax public class HeapQueue<T> where T : IComparable<T> Type Parameters Name Description T Constructors HeapQueue() Declaration public HeapQueue() Properties Count Declaration public int Count { get; } Property Value Type Description Int32 First Declaration public T First { get; } Property Value Type Description T IsEmpty Declaration public bool IsEmpty { get; } Property Value Type Description Boolean Methods Clear() Declaration public void Clear() Contains(T) Declaration public bool Contains(T item) Parameters Type Name Description T item Returns Type Description Boolean Peek() Declaration public T Peek() Returns Type Description T Pop() Declaration public T Pop() Returns Type Description T Push(T) Declaration public void Push(T item) Parameters Type Name Description T item Remove(T) Declaration public void Remove(T item) Parameters Type Name Description T item"
  },
  "api/Global.HighscoreController.html": {
    "href": "api/Global.HighscoreController.html",
    "title": "Class HighscoreController | Morpy",
    "keywords": "Class HighscoreController Controller who manages all high scores and times. The current implementation only has the time measurement. Inheritance Object HighscoreController Namespace : Global Assembly : cs.temp.dll.dll Syntax public class HighscoreController : MonoBehaviour Methods CheckTimeIsNewHighScore(TimeSpan) Checks if a given TimeSpan is a better highscore fpr the current llevel Declaration public bool CheckTimeIsNewHighScore(TimeSpan timeSpan) Parameters Type Name Description TimeSpan timeSpan Returns Type Description Boolean GetCurrentTime() Reads the current TimeSpan, from start to now. Declaration public TimeSpan GetCurrentTime() Returns Type Description TimeSpan GetSavedHighScore() Reads the Highscore TimeSpan for the current level. Declaration public TimeSpan GetSavedHighScore() Returns Type Description TimeSpan GetSavedHighScoreForLevelByName(String) Reads the Highscore TimeSpan for a specific level. Return the TimeSpan.Zero, Declaration public static TimeSpan GetSavedHighScoreForLevelByName(string level) Parameters Type Name Description String level Returns Type Description TimeSpan SaveHighScore(TimeSpan) Saves a HighScore for the current Level to the user pref. Declaration public static void SaveHighScore(TimeSpan timeSpan) Parameters Type Name Description TimeSpan timeSpan StartMeasurement() sets the the current Time. Declaration public void StartMeasurement()"
  },
  "api/Global.html": {
    "href": "api/Global.html",
    "title": "Namespace Global | Morpy",
    "keywords": "Namespace Global Classes AstarPath AttackableAttacker This component can be added to all objects that can attack others and that can be attacked by others Other components need to activate the \"attackNearest\" Method in this class in order for this attack to attack. AttackEntersLeavesCooldown Event which is executed, when the Attacker enters or leave a cooldown AudioManager AudioManager that handles playing audio in levels and the main menu Source: https://www.youtube.com/watch?v=6OT43pvUyfY CameraController DeathZone Defines a Zone in which the player should immediately die, when he enters the zone EnablePlayerInput Event which enabled the input of the player EnemyAI Class defining the behaviour of hostile entities EnemyArtifact This class only contains the charakter type of a artifact, which has been dropped by a dead enemy EnemyArtifactSpawner Artifact Spawner, which contains all artifacts of dead enemys EnemyDeath Event which disable the enemy gameobject and spawns a new artifact EventManager Events are pooled, with a default capacity of 4 instances. EventManager.Event An event is something that happens at a point in time in a simulation. EventManager.Event<T> Event adds the ability to hook into the OnExecute callback whenever the event is executed. GameController Basic game controller with contains the platformer model GoalZone Defines a Zone in which the player conpleted the level Health Basic health controller for the player and the enemies. HealthBarController HealthIsZero Event which manages the case, when a player or a enemy has no health points HeapQueue<T> HighscoreController Controller who manages all high scores and times. The current implementation only has the time measurement. KinematicObject Implements game physics for some in game entity. LevelController Controller to manage all levels and unlock them. LoadLevel Event which loads a new level MainMenuScript Main Menu Script Handles actions on the main menu scene MorphPlayer Event which changes the target charakter type of the player by a enemy artifact PauseMenuScript Pause Menu Script Handles opening and closing the pause menu PlatformerModel PlayerController The player controller manges all actions perfomed by the player, the input, special actions and parameters for the charakter types PlayerDeath Event which handles the death of the player PlayerEnteredDeathZone Event that makes the player die when he enters the death zone PlayerEnteredGoal Event thathandles the case, if the player entered the goal PlayerSpawn Event that re-spawns the player on the start position RotateToGravity Class for rotating an object with the gravity acting on the device. RotateWorld Event that inverts the player movement and flip texture, when the device is rotated Sound An audio clip for the Audio Manager SpawnPoint Defines the spawn point in a level Enums AstarPath.AstarDistribution Information about where the package was downloaded CharacterType Defines all available charakter types EnemyAI.MovementState The different kind of states of movement a charakter can be in. PlayerController.JumpState defines all jump states PlayerController.MovementState Definces all movement states RoateDirection Enum with all rotate directions"
  },
  "api/Global.KinematicObject.html": {
    "href": "api/Global.KinematicObject.html",
    "title": "Class KinematicObject | Morpy",
    "keywords": "Class KinematicObject Implements game physics for some in game entity. Inheritance Object KinematicObject PlayerController Namespace : Global Assembly : cs.temp.dll.dll Syntax public class KinematicObject : MonoBehaviour Fields gravityModifier A custom gravity coefficient applied to this entity. Declaration public float gravityModifier Field Value Type Description Single Invert Declaration protected int Invert Field Value Type Description Int32 invertedMovement The current velocity of the entity. Declaration public bool invertedMovement Field Value Type Description Boolean minGroundNormalY The minimum normal (dot product) considered suitable for the entity sit on. Declaration public float minGroundNormalY Field Value Type Description Single TargetVelocity Declaration protected Vector2 TargetVelocity Field Value Type Description Vector2 velocity The current velocity of the entity. Declaration public Vector2 velocity Field Value Type Description Vector2 Properties IsGrounded Is the entity currently sitting on a surface? Declaration protected bool IsGrounded { get; } Property Value Type Description Boolean Methods Bounce(Single) Bounce the object's vertical velocity. Declaration public void Bounce(float value) Parameters Type Name Description Single value Bounce(Vector2) Bounce the objects velocity in a direction. Declaration public void Bounce(Vector2 dir) Parameters Type Name Description Vector2 dir ComputeVelocity() Declaration protected virtual void ComputeVelocity() FixedUpdate() Declaration protected virtual void FixedUpdate() OnDisable() Declaration protected virtual void OnDisable() OnEnable() Declaration protected virtual void OnEnable() Start() Declaration protected virtual void Start() Teleport(Vector3) Teleport to some position. Declaration public void Teleport(Vector3 position) Parameters Type Name Description Vector3 position Update() Declaration protected virtual void Update()"
  },
  "api/Global.LevelController.html": {
    "href": "api/Global.LevelController.html",
    "title": "Class LevelController | Morpy",
    "keywords": "Class LevelController Controller to manage all levels and unlock them. Inheritance Object LevelController Namespace : Global Assembly : cs.temp.dll.dll Syntax public class LevelController : MonoBehaviour Methods getHighestCompletedLevel() Get the highest level the user completed Declaration public static int getHighestCompletedLevel() Returns Type Description Int32 highestCompletedLevel as integer setHighestCompletedLevel(Int32) Set the highest level, the player has completed Example: LevelController.setHighestCompletedLevel(currentLevel); Declaration public static void setHighestCompletedLevel(int val) Parameters Type Name Description Int32 val"
  },
  "api/Global.LoadLevel.html": {
    "href": "api/Global.LoadLevel.html",
    "title": "Class LoadLevel | Morpy",
    "keywords": "Class LoadLevel Event which loads a new level Inheritance Object EventManager.Event EventManager.Event < LoadLevel > LoadLevel Inherited Members EventManager.Event<LoadLevel>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class LoadLevel : EventManager.Event<LoadLevel>, IComparable<EventManager.Event> Fields levelName Declaration public string levelName Field Value Type Description String Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.MainMenuScript.html": {
    "href": "api/Global.MainMenuScript.html",
    "title": "Class MainMenuScript | Morpy",
    "keywords": "Class MainMenuScript Main Menu Script Handles actions on the main menu scene Inheritance Object MainMenuScript Namespace : Global Assembly : cs.temp.dll.dll Syntax public class MainMenuScript : MonoBehaviour Fields highscoreDisplays List of text boxes to display the highscores Declaration public GameObject[] highscoreDisplays Field Value Type Description GameObject [] levels List of level selection screens Declaration public GameObject[] levels Field Value Type Description GameObject [] levelSelection Level selection canvas Declaration public GameObject levelSelection Field Value Type Description GameObject mainMenu Main Menu canvas Declaration public GameObject mainMenu Field Value Type Description GameObject Methods OpenLevel(Int32) Start the game at a specific level Declaration public void OpenLevel(int level) Parameters Type Name Description Int32 level Level to start at OpenLevelSelect() Open the Level Select screen and hide the main menu Declaration public void OpenLevelSelect() OpenMainMenu() Open the Main Menu screen and hide the level select screen Declaration public void OpenMainMenu() QuitGame() Quit the application Declaration public void QuitGame() Start() Setup dynamic parts of the menu Declaration public void Start() StartGame() Open the Game Scene to start the game Declaration public void StartGame()"
  },
  "api/Global.MorphPlayer.html": {
    "href": "api/Global.MorphPlayer.html",
    "title": "Class MorphPlayer | Morpy",
    "keywords": "Class MorphPlayer Event which changes the target charakter type of the player by a enemy artifact Inheritance Object EventManager.Event EventManager.Event < MorphPlayer > MorphPlayer Inherited Members EventManager.Event<MorphPlayer>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class MorphPlayer : EventManager.Event<MorphPlayer>, IComparable<EventManager.Event> Fields gameObject Declaration public GameObject gameObject Field Value Type Description GameObject Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.PauseMenuScript.html": {
    "href": "api/Global.PauseMenuScript.html",
    "title": "Class PauseMenuScript | Morpy",
    "keywords": "Class PauseMenuScript Pause Menu Script Handles opening and closing the pause menu Inheritance Object PauseMenuScript Namespace : Global Assembly : cs.temp.dll.dll Syntax public class PauseMenuScript : MonoBehaviour Fields isPaused Is the pause menu currently paused? Declaration public static bool isPaused Field Value Type Description Boolean pauseButton GameObject for the pause button Declaration public GameObject pauseButton Field Value Type Description GameObject pauseMenuUI GameObject for the menu canvas Declaration public GameObject pauseMenuUI Field Value Type Description GameObject Methods GoToMenu() Open the Main Menu Declaration public void GoToMenu() Pause() Pause the game and show the pause menu Declaration public void Pause() reset() Reset the level Declaration public void reset() Resume() Resume the game and hide the pause menu Declaration public void Resume()"
  },
  "api/Global.PlatformerModel.html": {
    "href": "api/Global.PlatformerModel.html",
    "title": "Class PlatformerModel | Morpy",
    "keywords": "Class PlatformerModel Inheritance Object PlatformerModel Namespace : Global Assembly : cs.temp.dll.dll Syntax [Serializable] public class PlatformerModel Fields enemyArtifactSpawner Spawner for Enemy artifact, on enemy death event Declaration public EnemyArtifactSpawner enemyArtifactSpawner Field Value Type Description EnemyArtifactSpawner highscoreController The main component which controls the highscores Declaration public HighscoreController highscoreController Field Value Type Description HighscoreController jumpDeceleration A global jump modifier applied to slow down an active jump when the user releases the jump input. Declaration public float jumpDeceleration Field Value Type Description Single jumpModifier A global jump modifier applied to all initial jump velocities. Declaration public float jumpModifier Field Value Type Description Single player The main component which controls the player sprite, controlled by the user. Declaration public PlayerController player Field Value Type Description PlayerController spawnPoint The spawn point in the scene. Declaration public Transform spawnPoint Field Value Type Description Transform virtualCamera The virtual camera in the scene. Declaration public Cinemachine.CinemachineVirtualCamera virtualCamera Field Value Type Description Cinemachine.CinemachineVirtualCamera"
  },
  "api/Global.PlayerController.html": {
    "href": "api/Global.PlayerController.html",
    "title": "Class PlayerController | Morpy",
    "keywords": "Class PlayerController The player controller manges all actions perfomed by the player, the input, special actions and parameters for the charakter types Inheritance Object KinematicObject PlayerController Inherited Members KinematicObject.minGroundNormalY KinematicObject.gravityModifier KinematicObject.velocity KinematicObject.invertedMovement KinematicObject.IsGrounded KinematicObject.TargetVelocity KinematicObject.Invert KinematicObject.Bounce(Single) KinematicObject.Bounce(Vector2) KinematicObject.Teleport(Vector3) KinematicObject.OnEnable() KinematicObject.OnDisable() KinematicObject.Start() KinematicObject.FixedUpdate() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class PlayerController : KinematicObject Fields animator Current animation of the player Declaration public Animator animator Field Value Type Description Animator collider2d Defines the box collider 2D Declaration public BoxCollider2D collider2d Field Value Type Description BoxCollider2D controlEnabled indicates, if the input will be processed Declaration public bool controlEnabled Field Value Type Description Boolean health gives the player the ability to hab health points Declaration public Health health Field Value Type Description Health jumpState Defines the jump state. Declaration public PlayerController.JumpState jumpState Field Value Type Description PlayerController.JumpState movementState Defines the movement state Declaration public PlayerController.MovementState movementState Field Value Type Description PlayerController.MovementState spriteRenderer the texture of the playermodel Declaration public SpriteRenderer spriteRenderer Field Value Type Description SpriteRenderer targetCharacterType Defines the target character type Declaration public CharacterType targetCharacterType Field Value Type Description CharacterType Properties Bounds Defines the bounds of the 2d collider Declaration public Bounds Bounds { get; } Property Value Type Description Bounds Methods calculateDistanceToObject(GameObject) calculates the distance to a given game object Declaration public float calculateDistanceToObject(GameObject go) Parameters Type Name Description GameObject go the game object Returns Type Description Single ComputeVelocity() Computes the velocity of the player Declaration protected override void ComputeVelocity() Overrides KinematicObject.ComputeVelocity() getNearestEnemyArtifact() find the nearest gameobject in a given distance Declaration public GameObject getNearestEnemyArtifact() Returns Type Description GameObject the nearest game object morphNearest() changes the character type to the type of the nearest artifact in a given distance Declaration public void morphNearest() Update() Processes updates on every frame Declaration protected override void Update() Overrides KinematicObject.Update()"
  },
  "api/Global.PlayerController.JumpState.html": {
    "href": "api/Global.PlayerController.JumpState.html",
    "title": "Enum PlayerController.JumpState | Morpy",
    "keywords": "Enum PlayerController.JumpState defines all jump states Namespace : Global Assembly : cs.temp.dll.dll Syntax public enum JumpState Fields Name Description Grounded InFlight Jumping Landed PrepareToJump"
  },
  "api/Global.PlayerController.MovementState.html": {
    "href": "api/Global.PlayerController.MovementState.html",
    "title": "Enum PlayerController.MovementState | Morpy",
    "keywords": "Enum PlayerController.MovementState Definces all movement states Namespace : Global Assembly : cs.temp.dll.dll Syntax public enum MovementState Fields Name Description Sprinting Standing Walking"
  },
  "api/Global.PlayerDeath.html": {
    "href": "api/Global.PlayerDeath.html",
    "title": "Class PlayerDeath | Morpy",
    "keywords": "Class PlayerDeath Event which handles the death of the player Inheritance Object EventManager.Event EventManager.Event < PlayerDeath > PlayerDeath Inherited Members EventManager.Event<PlayerDeath>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class PlayerDeath : EventManager.Event<PlayerDeath>, IComparable<EventManager.Event> Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.PlayerEnteredDeathZone.html": {
    "href": "api/Global.PlayerEnteredDeathZone.html",
    "title": "Class PlayerEnteredDeathZone | Morpy",
    "keywords": "Class PlayerEnteredDeathZone Event that makes the player die when he enters the death zone Inheritance Object EventManager.Event EventManager.Event < PlayerEnteredDeathZone > PlayerEnteredDeathZone Inherited Members EventManager.Event<PlayerEnteredDeathZone>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class PlayerEnteredDeathZone : EventManager.Event<PlayerEnteredDeathZone>, IComparable<EventManager.Event> Fields DeathZone Declaration public DeathZone DeathZone Field Value Type Description DeathZone Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.PlayerEnteredGoal.html": {
    "href": "api/Global.PlayerEnteredGoal.html",
    "title": "Class PlayerEnteredGoal | Morpy",
    "keywords": "Class PlayerEnteredGoal Event thathandles the case, if the player entered the goal Inheritance Object EventManager.Event EventManager.Event < PlayerEnteredGoal > PlayerEnteredGoal Inherited Members EventManager.Event<PlayerEnteredGoal>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class PlayerEnteredGoal : EventManager.Event<PlayerEnteredGoal>, IComparable<EventManager.Event> Fields GoalZone Declaration public GoalZone GoalZone Field Value Type Description GoalZone Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.PlayerSpawn.html": {
    "href": "api/Global.PlayerSpawn.html",
    "title": "Class PlayerSpawn | Morpy",
    "keywords": "Class PlayerSpawn Event that re-spawns the player on the start position Inheritance Object EventManager.Event EventManager.Event < PlayerSpawn > PlayerSpawn Inherited Members EventManager.Event<PlayerSpawn>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class PlayerSpawn : EventManager.Event<PlayerSpawn>, IComparable<EventManager.Event> Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.RoateDirection.html": {
    "href": "api/Global.RoateDirection.html",
    "title": "Enum RoateDirection | Morpy",
    "keywords": "Enum RoateDirection Enum with all rotate directions Namespace : Global Assembly : cs.temp.dll.dll Syntax public enum RoateDirection Fields Name Description DOWN UP"
  },
  "api/Global.RotateToGravity.html": {
    "href": "api/Global.RotateToGravity.html",
    "title": "Class RotateToGravity | Morpy",
    "keywords": "Class RotateToGravity Class for rotating an object with the gravity acting on the device. Inheritance Object RotateToGravity Namespace : Global Assembly : cs.temp.dll.dll Syntax public class RotateToGravity : MonoBehaviour"
  },
  "api/Global.RotateWorld.html": {
    "href": "api/Global.RotateWorld.html",
    "title": "Class RotateWorld | Morpy",
    "keywords": "Class RotateWorld Event that inverts the player movement and flip texture, when the device is rotated Inheritance Object EventManager.Event EventManager.Event < RotateWorld > RotateWorld Inherited Members EventManager.Event<RotateWorld>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class RotateWorld : EventManager.Event<RotateWorld>, IComparable<EventManager.Event> Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.Sound.html": {
    "href": "api/Global.Sound.html",
    "title": "Class Sound | Morpy",
    "keywords": "Class Sound An audio clip for the Audio Manager Inheritance Object Sound Namespace : Global Assembly : cs.temp.dll.dll Syntax [Serializable] public class Sound Fields clip Audio Clip to play Declaration public AudioClip clip Field Value Type Description AudioClip loop Should the sound loop indefinately? Declaration public bool loop Field Value Type Description Boolean mixerGroup Mixer group to use for this sound Declaration public AudioMixerGroup mixerGroup Field Value Type Description AudioMixerGroup name Name of the audio clip used to reference it in the audio manager Declaration public string name Field Value Type Description String pitch Pitch of the sound. 1 for unchanged pitch Declaration public float pitch Field Value Type Description Single pitchVariance Optional pitch variance to play the sound at difference pitch randomly Declaration public float pitchVariance Field Value Type Description Single source AudioSource used across sounds - managed by the AudioManager Declaration public AudioSource source Field Value Type Description AudioSource volume Volume the clip should have Declaration public float volume Field Value Type Description Single volumeVariance Optional volume variance to play the sound at difference volumes randomly Declaration public float volumeVariance Field Value Type Description Single"
  },
  "api/Global.SpawnPoint.html": {
    "href": "api/Global.SpawnPoint.html",
    "title": "Class SpawnPoint | Morpy",
    "keywords": "Class SpawnPoint Defines the spawn point in a level Inheritance Object SpawnPoint Namespace : Global Assembly : cs.temp.dll.dll Syntax public class SpawnPoint : MonoBehaviour"
  },
  "index.html": {
    "href": "index.html",
    "title": "Morphy | Morpy",
    "keywords": "Morphy Documentation See here for full documentation: https://emm-gruppe8.github.io/Morphy/ About Morphy is a mobile game centered around movement. Turn, push and pull your phone and discover all the ways in which you can control the charakters, each one unlike the others. Jump high with bunny, use the brute force of the rhino or even turn the world upside down with slime. Only if you take full advantage of their abilities will you be able to escape! Movement Tilt your phone right or left to move into that direction Pull your phone towards you to jump Tap the left side of the screen to attack Tap the right side of the screen to change charakters Charakters Bunny Can Jump Attacks hard by jumping on enemies Rhino Gets very fast Attacks hard by ramming enemies Slime Can walk on floor as well as on ceiling Attacks hard by falling onto enemies Installation Android Download this file on your Android Phone: https://github.com/EMM-Gruppe8/Morphy/releases/download/v1.0/Morphy.apk Klick on the file to execute it (You might need to give permissions to execute the file) ### iOS Due to limitations by Apple, you need to compile the app yourself with your own Apple Developer Account. Build the game as a Xcode project for iOS. Import the Project in Xcode on your mac. Open the “Unity-iPhone.xcodeproj”. Create a provisioning profile for the game with your Apple Developer Account. Connect and select your iOS Device in Xcode. Compile the game on your device and play the Game."
  },
  "manual/Characters.html": {
    "href": "manual/Characters.html",
    "title": "Hase (Bunny) | Morpy",
    "keywords": "Hase (Bunny) Bewegung: Kann Laufen und springen Spezialattacke: Kann auf Gegner springen Nashorn (Rhino) Bewegung: Kann schnell laufen, aber nicht springen Spezialattacke: Kann Gegner rammen Schleim (Slime) Bewegung: Kann langsam laufen und die Seite wechseln Spezialattacke: Auf Gegner herabfallen Nicht implementierte Gegner Diese Gegner wurden am Anfang des Projektes konzeptioniert, jedoch nicht umgesetzt, da die den Projektrahmen sprengen würden: Schneckenhaus (Shell) Bewegung: Kann langsam laufen Spezialattacke: Tötet Gegner bei Kontakt und auf gegenüber liegender Seite, steckt dann jedoch fest, bis das Gerät so gedreht wird, dass es wieder auf den Beinen stehen kann Biene (Bee) Bewegung: Kann frei fliegen Spezialattacke: Kann nach unten schießen Stirbt jedoch, wenn es die Decke, Boden oder Wände berührt"
  },
  "manual/Reflection.html": {
    "href": "manual/Reflection.html",
    "title": "Selbsteinschätzung der Projektteilnehmer | Morpy",
    "keywords": "Selbsteinschätzung der Projektteilnehmer In den nachfolgenden Seiten haben alle Projektteilnehmer eine persönliche Einschätzung des Projektes und eine Selbsteinschätzung vorgenommen."
  },
  "manual/Reflection_Bennett.html": {
    "href": "manual/Reflection_Bennett.html",
    "title": "Selbsteinschätzung Bennett | Morpy",
    "keywords": "Selbsteinschätzung Bennett Aufgaben Meine Aufgabe zu Beginn des Projektes war es, das Pausen- und Hauptmenü zu erstellen. Hierbei konnte ich die Arbeit von den vorherigen Abgaben dieses Kurses als Basis nehmen. Die größte von mir umgesetzte Aufgabe war das Angriffssystem (Klasse \"AttackableAttacker\"), welches von den anderen Gruppenmitglieder*innen dazu genutzt wurde, um sowohl die Angriffe des Spielers als auch der Gegner umzusetzen. Auf dem von Constantin erstellten Health-System aufbauend habe ich eine Health-Bar hinzugefügt, welche automatisch über jedem Objekt angezeigt wird, welches die Health-Komponente besitzt. Als letztes und optionales Feature habe ich zusätzlich die Musik und Sound-Effekte zum Spiel hinzugefügt. Projekteinschätzung Mir hat das Projekt sehr viel Spaß bereitet. Die Aufgaben wurden im Allgemeinen so verteilt, wie die Gruppenmitglieder darauf Lust hatten. Hierdurch konnte man meist Aufgaben, die einen wirklich interessieren. Die regelmäßigen Treffen und die Projektleitung durch Leon haben dabei dazu geführt, dass das ganze Team auf einem Stand bleibt und die Branches nicht zu stark von einander gehen. Erkenntnisgewinne & Hürden Vor Beginn des Kurses hatte ich noch keine Erfahrungen mit Unity oder Spieleentwicklung im Allgemeinen. Zwar wurden in dem Kurs sehr gut die Grundlagen vermittelt, jedoch ist die freie Umsetzung von neuen Features im eigenen Projekt noch einmal eine ganz andere Hürde. Stark geholfen hat mir hier jedoch die große Anzahl an Tutorials und Forum-Einträgen zu Unity online, welche oft auch als relativer Anfänger gut zu verstehen sind. Anteil am Projekt Nach meinem empfinden habe ich einen fairen Anteil am Projekt mitgearbeitet. In den Team-Treffen wurden die Aufgaben jedes mal so verteilt, dass alle Mitglieder*innen einen etwa gleich großen Anteil bekommen und sich niemand überfordert fühlt."
  },
  "manual/Reflection_Constantin.html": {
    "href": "manual/Reflection_Constantin.html",
    "title": "Selbsteinschätzung Constantin | Morpy",
    "keywords": "Selbsteinschätzung Constantin Aufgaben Meine größte Aufgabe war die Entwicklung des „PlayerController“ zur Steuerung der Spielfigur. Dazu gehört die Umsetzung der Steuerung über den Beschleunigungssensor, aber auch die Physik, damit der Schleim die Seite wechseln kann. Ebenfalls im PlayerController habe ich auch die Spezialfunktionen für den Spieler implementiert und dabei unteranderem auf das Angriffssystem zugegriffen, welches Bennett erstellt hat. Im PlayerController waren zwischendurch einige Änderungen nötig, da ein paar Dinge nicht wie gewünscht funktioniert haben, was aber erst im Verlauf des Projektes aufgefallen war. Des Weiteren habe ich, inspiriert von einer Unity 2D Demo, den Event-Manager und entsprechende Events in unser Projekt eingebaut, welche den Spielertod in gewissen Situationen verursachen, Zielzonen definieren oder andere Event-Ketten auslösen. Die Health Klasse und ein paar weitere kleinere Klassen habe ich ebenfalls implementiert, um die Funktionen des PlayControllers frühzeitig testen zu können. Als Optionales Feature habe ich noch den HighscoreController umgesetzt, der die Zeit misst, welche der Spieler je Level benötigt. Die Funktionsweise ist aufgrund der Priorität dabei recht rudimentär geblieben. Projekteinschätzung Ich habe das ganze Projekt als sehr angenehm empfunden, jeder konnte sich gut in unterschiedlichen Themen einbringen und man konnte sich auf das Team verlassen. Das Endprodukt gefällt mir sehr, ich bin auch positiv überrascht, wie gut die einzelnen Anforderungen und Features am Ende funktioniert haben. Erkenntnisgewinne & Hürden Die wohl größte Hürde war, dass ich außerhalb des Kurses noch keine Erfahrung mit Unity sammeln konnte und ich besonders am Anfang etwas Schwierigkeiten hatte mir Vorzustellen wie unsere Anforderungen eigentlich konkret umgesetzt werden könnten. Eben diese Hürde hat aber auch zu den größten Erkenntnissen geführt, sodass ich jetzt ein sichereres Gefühl im Umgang mit Unity habe. Ich kann dabei besonders die Fähigkeit des Schleims die Seiten zu wechseln hervorheben, diese war für mich in der Umsetzung schon eine Herausforderungen, hat mir aber auch einen tiefen Einblick in das Spiel und die Physik gegeben. Anteil Zusammengefasst habe ich das Gefühl einen gerechten Anteil an dem Projekt übernommen zu haben."
  },
  "manual/Reflection_Leon.html": {
    "href": "manual/Reflection_Leon.html",
    "title": "Selbsteinschätzung Leon | Morpy",
    "keywords": "Selbsteinschätzung Leon Projektmanagement Dies ist das erste Projekt bei dem ich die Rolle des Projektmanagers in einer Gruppe übernommen habe. Da ich mir den Grundgedanken für dieses Projekt ausgedacht hatte, war es ein natürlicher Schritt diese Rolle zu füllen. Ich hatte mich vorher immer vor dieser Rolle gedrückt, da ich mich nicht dafür bereit gefühlt hatte und Angst davor hatte, dass ein von mir geleitetes Projekt scheiterten würde. Doch für dieses Projekt fühlte es sich richtig an, da ich das Gefühl hatte die Richtigen Werkzeuge für diese Aufgabe gefunden zu haben. In der Rolle des PM habe ich folgende Arbeitsweisen in diesem Projekt etabliert, die sich über die Zeit gewandelt haben: Je nach Projektlage wöchentliche bis halbwöchentliche Treffen zur Planung und Absprache Dokumentation der Entscheidungen via Protokollen Das Github-repository als einzige Quelle von Information ergänzt durch einen Discord-Chat Eine ticketbasierte (Issues) Arbeitsweise die im Zusammenhang mit Kanban-Board von Github stets den Fortschritt des Projekts ersichtlich gemacht hatte Ein Pull-Request basierte Feature-Entwicklung bei der jede PR der Überprüfung eines kompetenznahen Gruppenmitglieds erfordert Ein Issue-basiertes Bug-Reporting wobei die Issues einem kompetentem Gruppenmitglied zugeordnet wurden Einen automatischen Dokumentations-Deployment Prozess wobei dokumentierter Code im main-branch automatisch auf einer Github-Website deployt wird. Ich hoffe das all diese Methoden dazu beigetragen haben, dass wir effizient arbeiten konnten und wenige Unklarheiten entstanden sind. Persönlich habe ich Das Projekt als überraschend stressfrei erlebt, und habe zumindest nichts anderes von meinen Teammitgliedern mitbekommen. Natürlich ist unser Vorschritt nur durch die gute Arbeit aller Teammitgleider zustande gekommen und ich bin dankbar mit diesem Team zusammengearbeitet zu haben. Entwicklung Ich habe mich in der Entwicklung besonders auf die Implementation der KI-Gegner konzentriert. Hierbei habe ich den die Implementierung des A -Algorithmus durch das A -Project verwendet und sie für unsere Zwecke verändert. Da diese Implementierung eher auf 3D- und Top-down Spiele ausgelegt ist, waren einige Veränderungen nötig um sie für unsere Projekt nutzbar zu machen. Der Beste weg wäre wohl gewesen, die Kostenbestimmung für dieses Grid-basierte verfahren zu verändern. Aus Zeitgründen habe ich mich jedoch entschieden auf Rajtracking für die Gegnererkennung und zB. die Bodenloch-Erkennung zu setzen. Dies hatte auch den Vorteil, das ich nicht für jeden Charakter eine neue Kostenbestimmung schreiben musste. Andere Aufgaben die ich übernommen habe war das Designen der Level, das Erforschen des Steuerung durch Bewegung, die Integration unserer ersten Prototypen und einiges der Dokumentation zu schreiben. Erkenntnisgewinne & Hürden Ich habe vorallem viel über Projektmanagement gelernt aber auch über Pathfinding und den Unterschied zwischen Beschleuningunssensoren eines Handys und dem Gyroscop. Die größte Hürde war für mich auf jeden Fall die Rolle des Projektmanagers zu übernehmen. Anteil Ich denke ich habe einen fairen Anteil der Arbeit übernommen"
  },
  "manual/Reflection_Magdalena.html": {
    "href": "manual/Reflection_Magdalena.html",
    "title": "Selbsteinschätzung Magdalena | Morpy",
    "keywords": "Selbsteinschätzung Magdalena Einleitung Bei unserem ersten Treffen konnte sich jeder selbst aussuchen, woran er arbeiten möchte. Ich fand das sehr spannend und chillig, weil jeder an dem arbeiten konnte, was ihn interessiert. Ich habe an der Animation der Charaktere gearbeitet, herausgefunden, wie man die Terrain-Assets nutzen kann, als auch die Gegner AI recherchiert und Pathfinding implementiert. Animation Wir haben kostenlose Assets aus dem Unity-Store verwendet. Es gab bereits Sprites für die Animation, also habe ich im Animator Tab gearbeitet, wo ich die Samples auf 12 gesetzt habe. Sonst wird die Animation zu schnell dargestellt. Im Animator Tab ist es sehr wichtig, wie man die Pfeile setzt und was mit was verbunden ist. Was ich meine, ist, dass es wichtig ist, dass der erste Zustand /Idle/ mit dem Entry State verbunden ist. Von dort aus musste ich die Zustände Jump und Walk verbinden - besonders bei dem Bunny Charakter. Das Nashorn und der Slime Charakteren können nicht springen, also sie hatten nur Idle und Walk State. Terrainassets Für das Terrain habe ich eine Tilemap verwendet. Zunächst wurden die Terrain Slices aus dem Asset zu klein dargestellt, sobald man auf der Tilemap zeichnete. Ich konnte es beheben, indem ich die Pixel pro Einheit auf 16 gesetzt habe. AI/Pathfinding Ich habe das Projekt A* ausgewählt, weil ich finde, dass die Implementierung einfacher ist. Wichtig ist, dass im A*Objekt > Pathfinder > Gridgrpah > Diameter kleiner als 1 ist, in unserem Fall ist es 0,5, sonst war der Gridgraph, der den Charakteren sagt, wo sie laufen können und wo nicht, immer über dem eigentlichen Boden. Die Charaktere würden also dann \"fliegen\". Erkenntnisgewinne & Hürden Für mich war es am schwierigsten, mich an die Arbeit in einem Team mit Leuten zu gewöhnen, die ich vorher nicht kenne. Aber das hat mir tatsächlich in dem Sinne geholfen, dass ich mich jetzt selbstbewusster fühle. Ich habe gelernt, dass es nichts Schlechtes ist, Fragen zu stellen, da dies ein Teil der Teamarbeit ist. Anteil Ich habe das Gefühl, dass ich mehr für unser Team hätte tun können, aber ich bin wirklich glücklich, wie das Spiel am Ende ausgegangen ist."
  },
  "manual/Requirements.html": {
    "href": "manual/Requirements.html",
    "title": "Beschreibung: | Morpy",
    "keywords": "Beschreibung: Der Spieler spielt einen Virus in einem 2D Jump ‘n Run, welcher die Fähigkeiten von Gegnern übernehmen kann. Attackiert und besiegt der Spieler beispielsweise einen fliegenden Gegner, so kann der Spieler nun selber fliegen. Der Spieler kann hierbei immer nur die Fähigkeiten einer Spielfigur gleichzeitig besitzen: Kann der Spieler zur Zeit fliegen und tötet einen Gegner, welcher an Wänden laufen kann, so kann der Spieler nun an Wänden laufen, jedoch nicht mehr fliegen. Der Spieler muss hierbei die Fähigkeiten verschiedener Gegner nutzen, um das Level erfolgreich zu durchqueren, es kommt also auch auf das Geschick des Spielers an, das Level mit den richtigen Fähigkeiten möglichst schnell zu meistern. Plattform: iOS + Android Funktionale Anforderungen 1. Steuerung / Interaktionen Die Spielfigur wird über die Gyroskopsensor bzw. Beschleunigungssensor des Smartphones bewegt. Die Geschwindigkeit der Spielfigur passt sich dabei der Neigung an, sodass diese auch sprinten kann Charaktere verhalten sich unterschiedlich zur Schwerkraft, bzw Interaktion damit Die Angriffe werden über die Touch-Eingabe aktiviert. Der Wechsel zwischen Charakteren wird über Touch-Eingaben aktiviert. Erfüllungsgrad: 100% 2. Leveldesign Es soll in jedem Level Hindernisse geben, die es zu überwinden gilt. Es soll dabei nicht möglich sein, das Level nur mit einer Fähigkeit durchzuspielen, sodass der Spieler gezwungen wird sich andere Fähigkeiten zu besorgen. höhere Hindernisse können durch Springen überwunden werden (Stein) sehr Hohe Hindernisse können nur durch wechsel der Seite (oben/unten) überwunden werden Gräben können nur durch Springen oder Seitenwechsel überwunden werden weite Schluchten können nur mit Sprinten überwunden werden (Springen von Berg) Erfüllungsgrad: 100% 3. Levelfortschritt Es gibt drei unterschiedliche Level, die erst freigeschaltet werden, nachdem das vorherige erfolgreich durchgespielt wurde. Die Level werden dabei schwieriger, um die Herausforderung für geübte Spieler zu erhöhen Erfüllungsgrad: 100% 4. UI und Menüs Im Hauptmenü kann der Spieler direkt weiterspielen, freigeschaltete Level auswählen und seine Zeiten einsehen. Im Pausenmenü kann der Spieler das Spiel pausieren, komplett neustarten und zurück zum Hauptmenü gehen Erfüllungsgrad: 100% 5. Fähigkeit Seitenwechsel Charakter mit dieser Fähikeit sollte beim auf-den-Kopfstellen des Smartphones auf die gegenüberliegende Seite fallen und dort genau so laufen können, wie auf der anderen (Charakter: Slime) Erfüllungsgrad: 100% 6. Fähigkeit Hüpfen Durch Ranziehen des Handys kann der Charakter hüpfen (Charakter: Bunny) Je nach Stärke der Bewegung kann die Höhe des Sprungen moduliert werden Erfüllungsgrad: 100% 7. Fähigkeit übernehmen Die Fähigkeit eines besiegten Gegners kann übernommen werden In der Nähe des Leichnahms kann ein Button gedrückt werden um die Fähigkeit zu übernehmen Erfüllungsgrad: 100% 8. Gegner AI Gegner mit verschiedenen Eigenschaften haben unterschiedliche Verhaltensweisen beim Kampf und in der Fortbewegung und verwenden sie gegen den Spieler Erfüllungsgrad: 100% 9. Gesundheitssystem Der Spieler und die Gegner haben ein Gesundheitssystem basieren auf Health-Points, welche im Fern- oder Nahkampf reduziert werden. Erfüllungsgrad: 100% 10. Kampfsystem Charaktere können durch charakterspezifische Aktionen Gegner sofort Ausschalten (Auf den Kopf springen: Hase, Rammen: Nashorn, Auf Gegner fallen: Slime) Charakter können durch Boxen geringen Schaden ausrichten (für alle Charaktere gleich). Dies wird durch einen virtuellen Button ausgelöst Erfüllungsgrad: 100% (Optional). Bestzeiten Die Zeit, die der Spieler für ein Level benötigt, wird gespeichert, das erhöht den Wiederspielwert, da der Spieler seine eigenen Bestzeiten einsehen kann Erfüllungsgrad: 100% (Optional) Feedback über Vibration des Smartphones Wird der Spieler verletzt, oder stirbt vibriert das Smartphone, um dem Spieler ein besseres Feedback zu geben Erfüllungsgrad: 0% (Optional) Audio Aktionen und Bewegungen verursachen unterschiedliche Töne(Optional) Checkpoints Es können Checkpoints erreicht werden, bei denen der Spieler im Falle seines Todes wieder starten kann. Der Spieler kann dabei jederzeit zum letzten Checkpoint zurückkehren Erfüllungsgrad: 50% (Optional) Fähigkeit: Fliegen Charakter “Biene” kann fliegen und aus der Luft angreifen Nach dem Töten des Gegners erscheint an der Stelle der Tötung ein Orb Der Spieler besitzt ein Rand seines Bildschirms einen “Morph” Button, welcher aktiv wird, wenn ein Orb in der Nähe ist Ähnlich zu dem “Report” Button in \"Among Us\" Nach Drücken des Buttons holt der Spieler sich die Fähigkeit des Orbs Der Spieler kann sein Gerät nun neigen, um sich auch hoch unten runter zu bewegen Erfüllungsgrad: 0% (Optional) Fähigkeit: Grappling Hook Charakter “Chameleon” kann mit Hilfe der Zunge an Wände, Böden, Decke haften und sich dort selber hinziehen - kann jedoch nicht normal laufen Morphing funktioniert wieder gleich wie unter 5. Fähigkeit: Fliegen Die Fähigkeit kann genutzt werden, in dem auf eine Wand/Decke/Boden getippt wird Erfüllungsgrad: 0% Nicht-Funktionale Anforderungen Benutzerfreundlichkeit in der Bedienung und in den Menüs Unterstützung verschiedener Auflösungen und Bildschirmverhältnisse bei den Smartphones. Erfüllungsgrad: 100%"
  },
  "manual/Sources.html": {
    "href": "manual/Sources.html",
    "title": "Graphic Assets: | Morpy",
    "keywords": "Graphic Assets: “Pixel Adventure 1” https://assetstore.unity.com/packages/2d/characters/pixel-adventure-1-155360 “Pixel Adventure 2” https://assetstore.unity.com/packages/2d/characters/pixel-adventure-2-155418#reviews Pathfinding basis: \"A\\ Pathfinding Project\" * https://arongranberg.com/astar/ Audio Manager Brackey's Audio Manager https://www.youtube.com/watch?v=6OT43pvUyfY / https://brackeys.com/wp-content/FilesForDownload/AudioManager.zip Health Bar Basierend auf Brackey's Unity Health Bar UI , jedoch für das Projekt angepasst https://www.youtube.com/watch?v=BLfNP4Sc_iA Knockback/Impact System Basierend auf http://answers.unity.com/answers/309747/view.html Event-Manager / Kinematic-Object Basiert auf dem integrierten Unity 2D Beispielprojekt und wurde für dieses Projekt angepasst."
  },
  "manual/System.html": {
    "href": "manual/System.html",
    "title": "System | Morpy",
    "keywords": "System Die Komponenten der App lassen sich in drei Kategorien einteilen. Hardwarekomponenten (Grün): Die erste Kategorie, im Systembild grün dargestellt, sind die die verwendeten Hardwarekomponenten. Die Schnittstellen zu diesen Komponenten werden von den Betriebssystemen Android oder iOS zur Verfügung gestellt und durch Unity angesprochen. Display: Der Display dient der Anzeige des Spiels. Touch-Input: Der Touch Input wird für die Menü- und Aktionssteuerung benötigt. Während des Spiel läuft, dient die rechte Hälfte der Aktion zum „Morphen“, wenn sich ein entsprechendes Artefakt in der Nähe befindet. Die über die linke Hälfte kann der Spieler den nächstgelegenen Gegner angreifen. Acceleration Sensor / Beschleunigungssensor: Wie im Kaptiel „Verwendete Technologien“ erwähnt, wird der Beschleunigungssensor für die Bewegungssteuerung genutzt. Die X-Achse dient der horizontalen Bewegung. Je nach Neigung läuft die Spielfigur unterschiedlich schnell. Die Y-Achse wird für das Springen genutzt, dabei muss der Spieler das Smartphone schnell zu sich ran ziehen oder wegdrücken, um die Spielfigur springen zu lassen. Die Z-Achse wird ausgelesen, um zu erkennen, wenn das Smartphone auf umgedreht wird, z.B. um den Schleim auf die andere Seite fallen zu lassen. System- und Umgebungskomponenten (Blau) Die im Systembild blau dargestellten Komponenten sind alle Teil des Unity-Spiels und sind für alles zuständig, was nicht direkt mit den Spielfiguren zu tun hat. Game Controller: Als zentrale Verwaltung steht der Game Controller in der Mitte. Dieser erstellt Instanzen von den anderen verbunden Komponenten und bietet einen zentralen Zugriff auf diese. Der Game Controller ist somit auch die Verbindung zwischen den Blauen und den roten Komponenten. Die Instanzen werden als Singleton erstellt. Artefakt Spawner: Der Artefakt Spawner beinhaltet alle Orbs bzw. Artefakte, die ein Gegner im Todesfall hinterlässt. Ist ein Gegener besiegt werden, anhängig vom Charakter Typ, neue Instanzen eines Prefab erzeugt. Nach dem ein Artefakt genutzt wurde, deaktiviert die Komponente dieses. Die Artefakte haben die Primärfarbe des dazugehörigen Charakters. Highscore Controller: Diese Komponente misst die Zeit. Bei jedem Start eines Level, bzw Re-Spawn des Spielers, wird die Messung gestartet und in der Zielzone beendet. Ist die Zeit besser als die vorherige wird diese in den User Prefs gespeichert. Virtual Camera: Die Virtuelle Camera ist eine „CinemachineVirtualCamera“ aus dem Cinemachine Paket. Die Kamera ist an den Spieler gebunden, damit diese immer den Spieler zentriert. Cinemachine wird genutzt um zu erreichen, dass die Kamera sich niemals aus dem Spielfeld beweg und ggf. die Zentrierung löst, wenn der Spieler z.B. in einen Abgrund fällt. Die Komponente spricht den Physikalischen Bildschirm an. Level Controller Der Level Controller verwaltet alle drei Level. Die Komponente ermöglich das Laden von Levels, sichert dabei aber ab, dass nur bereits freigeschaltete Level geladen werden können. Hat ein Spieler ein Level erfolgreich abgeschlossen, schaltet diese Komponente das nächste Level frei. Die Daten werden in den User Prefs gespeichert. UI / Benutzeroberfläche Die UI-Komponente beinhaltet alle Bestandteile der Benutzeroberfläche. Dazu gehört das Hauptmenü, aber auch das Pausenmenü, welches über einen Pause-Button auf dem Bildschirm aufgerufen werden kann. Die Komponente wird über den Touch-Input gesteuert und greift zum Laden der Level auf den Level Controller zu. Auch die Button für die linke und rechte Seite des Bildschirms sind hier enthalten. Spieler- und Gegnerkomponenten (Rot) Die rot dargestellten Komponenten betreffen den Spieler oder die Gegner. Es gibt zwei Hauptkomponenten, den Spieler und die Gegner. Beide teilen sich dann gemeinsame Komponenten, für Eigenschaften, die bei beiden gleich sind. Player Controller: Der Player Controller steuert und verwaltet den Spieler. Es ist die zentrale Komponente, in der auch die Steuerung implementiert ist. Für jeden Charakter Typ sind Werte für die verfügbaren Fähigkeiten, wie z.B. Springen oder Sprinten, definiert. Auch die Methoden zum Morphen, also dem Wechseln des Charakter Typen sind enthalten. Der Controller bleibt also immer der gleiche und reagiert nur unterschiedlich anhand des Charakter Typen. AI Enemy: Die Komponente für die Gegner KI beinhaltet die A* Wegfindung und Logiken um dem Spieler zu lokalisieren. Ebenso wird sichergestellt, dass die Gegner nicht einfach über Klippen laufen und in den Tod stürzen. Auch hier sind alle Fähigkeiten für die einzelnen Charaktertypen implementiert, sodass alle Gegenderten den gleichen Controller nutzen können. Health: Die Health Komponente ist eine Klasse, welche dem Spieler und auch den Gegnern eine maximale Gesundheit gibt. Methoden zum Reduzieren oder Erhöhen der Gesundheit sowie zum Auffüllen der gesamten Gesundheit sind vorhanden. Fällt die Gesundheit auf 0, wird ein Event ausgelöst. Animation Die Komponente zur Animation ist eine Vielzahl an verschiedenen Animation Controllern für jeden einzelnen Charaktertypen. Sie beinhaltet Animationen für den Stillstand, laufen, Sprinten und springen, sofern der jeweilige Charakter die Fähigkeit besitzt. Die Animationen werden von dem Spieler und auch von den Gegnern genutzt. Attackable / Atackker Diese Komponente sorgt dafür, dass die Spieler und Gegner überhaupt angreifen können und auch angegriffen werden können. Sie bietet Methoden um zu berechnen, welcher der nächstgelegene Feind ist und kann diese angreifen. Timeouts nach jedem Angriff erhöhen dabei die Komplexität des Kampfes. Die Unterscheidung zwischen Spieler und Gegner funktioniert über die Tags der Objekte und es wird zwischen der Spezialfähigkeit und einem normalen Kampf unterschieden. Kinematic Object Das Kinematic Object ist die Physik des Spielers für den Rigidbody. Es enthält grundlegende Methoden zur Bewegung des Objektes und invertiert die gesamte Steuerung, wenn der Spieler sich auf der Decke bewegt. Da die Bewegung der Gegner anders realisiert wurde für A*, ist diese Klasse nur Teil des Spielers. Event-Manager (Lila) Der Event-Manager ist Lila eingefärbt, da er eigentlich als eine blaue Systemkomponente zu sehen ist, aber stark mit den Spieler und den Gegnern interagiert. Der Manager nutzt das Event Queue Pattern und baut Eventwarteschlangen auf, die sich beliebig verketten lassen. Die eigentlichen Events können dabei auf alle Komponenten zugreifen. Ein Beispiel für ein Event ist, wenn der Spieler kein Leben mehr hat, wird der Tod ausgelöst, was wiederum die Steuerung kurzfristig deaktiviert und anschließend das Level neu startet. Aber auch das Erreichen eines Ziel oder das Drehen des Bildschirmes sind Events, welche über den Event-Manager ausgeführt werden."
  },
  "manual/Technologies.html": {
    "href": "manual/Technologies.html",
    "title": "Verwendete Technologien: | Morpy",
    "keywords": "Verwendete Technologien: Unity Das Spiel baut komplett auf Spiele-Engine Unity auf. Es wurden für die Grafiken dabei einige Assets aus dem Unity Asset Store verwendet. Die Entwicklung der Softwarekomponenten erfolgte in der Unity-Version 2020.3.3f1. A* Die Wegfindung der Gegner wurde mithilfe des A+ Pathfinding Project realisiert. Link zum Projekt: https://arongranberg.com/astar/ Android/iOS Die Entwicklung selbst erfolgte weiterhin über ein herkömmliches Desktop-Betriebssystem, jedoch sind die Zielsysteme ausschließlich Smartphones mit Android oder iOS. Während der Entwicklung konnte die Unity Remote App verwendet werden, damit die App nicht bei jeder kleinen Codeänderung die App kompiliert werden muss. Die Remote-App leitet dabei die Steuerung an den Entwicklungs-Computer weiter. Die Qualität und Performance entsprechen dabei aber nicht einer nativen App. Die App steht als .apk Datei für Android zur Verfügung. Eine Datei für iOS können wir aufgrund von Einschränkungen von Apple nicht zur Verfügung stellen, diese muss für jedes Gerät und jedem Nutzer einzeln mit Xcode (nur macOS) und einem Apple Developer Account erstellt werden. Eine Veröffentlichung im AppStore ist aufgrund der Gebühren nicht geplant. Touch-Input Die Aktionsteuerung in der App erfolgt über den Touchscreen der Smartphones. Dabei wird unabhängig von der Rotation die rechte hälfe für die Aktion zum Morphen genutzt und die linke hälfte zum Angriff, beides nur sofern entspreche Gegner oder Artefakte sich in der Reichweite befinden. Natürlich erfolgt auch die Navigation im Menü über den Touchscreen. Beschleunigungssensor Die wichtigste Technologie für die gesamte Bewegungssteuerung ist der Beschleunigungssensor, welcher im Smartphone verbaut ist. Über die X-Achse kann man die Spielfigur laufen oder Sprinten lassen, über Ruckartige Bewegungen auf der Y-Achse springt die Spielfigur und die Z-Achse dient der Rotation. Die Intensität der Neigung oder Beschleunigung wird dabei auf die Spielfigur übertragen, bis zu einem vom Character abhängigen Schwellenwert. GitHub Als Versionsverwaltungssystem haben wir GitHub verwendet. Dabei haben wir eine „Organisation“ angelegt und alle Projektteilnehmer mit den höchsten Rechten ausgestattet. Features und Fehlerbehebungen wurden jeweils in einem eigenen Branch entwickelt und nach erfolgreicher Review in den Main-Branch zusammengeführt. GitHub haben wir zudem auch für die Aufgabenverteilung genutzt, indem Task und Issues dem jeweiligen Verantwortlichen zugeordnet werden konnten. DocFX Für die Dokumentation haben wir uns für DocFX entschieden. Eigene Methoden im Code wurden vom jeweiligen Autor kommentiert. Beim Push in den Master wird die DocFX API-Dokumentation automatisch aus den Code generiert. Die Schriftliche Projektdokumentation erfolgte manuell in nach Thema organisierten Markdown Dateien, die ebenfalls beim Push in den Main-Branch automatisch zu einer Dokumentation zusammengefasst werden."
  }
}