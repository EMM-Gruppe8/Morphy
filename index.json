{
  "api/Global.AstarPath.AstarDistribution.html": {
    "href": "api/Global.AstarPath.AstarDistribution.html",
    "title": "Enum AstarPath.AstarDistribution | Morpy",
    "keywords": "Enum AstarPath.AstarDistribution Information about where the package was downloaded Namespace : Global Assembly : cs.temp.dll.dll Syntax public enum AstarDistribution Fields Name Description AssetStore PackageManager WebsiteDownload"
  },
  "api/Global.AstarPath.html": {
    "href": "api/Global.AstarPath.html",
    "title": "Class AstarPath | Morpy",
    "keywords": "Class AstarPath Inheritance Object AstarPath Namespace : Global Assembly : cs.temp.dll.dll Syntax public class AstarPath : VersionedMonoBehaviour Fields active Returns the active AstarPath object in the scene. Note: This is only set if the AstarPath object has been initialized (which happens in Awake). Declaration public static AstarPath active Field Value Type Description AstarPath batchGraphUpdates Throttle graph updates and batch them to improve performance. If toggled, graph updates will batched and executed less often (specified by AstarPath.graphUpdateBatchingInterval . This can have a positive impact on pathfinding throughput since the pathfinding threads do not need to be stopped as often, and it reduces the overhead per graph update. All graph updates are still applied however, they are just batched together so that more of them are applied at the same time. However do not use this if you want minimal latency between a graph update being requested and it being applied. This only applies to graph updates requested using the AstarPath.UpdateGraphs(Bounds,System.Single) method. Not those requested using AstarPath.RegisterSafeUpdate(System.Action) or AstarPath.AddWorkItem(System.Action) . If you want to apply graph updates immediately at some point, you can call AstarPath.FlushGraphUpdates . See: graph-updates (view in online documentation for working links) Declaration public bool batchGraphUpdates Field Value Type Description Boolean Branch Which branch of the A* %Pathfinding Project is this release. Used when checking for updates so that users of the development versions can get notifications of development updates. Declaration public static readonly string Branch Field Value Type Description String colorSettings Reference to the color settings for this AstarPath object. Color settings include for example which color the nodes should be in, in the sceneview. Declaration public AstarColor colorSettings Field Value Type Description AstarColor data Holds all graph data Declaration public AstarData data Field Value Type Description AstarData debugFloor Low value to use for certain AstarPath.debugMode modes. For example if AstarPath.debugMode is set to G, this value will determine when the node will be completely red. Note: Only relevant in the editor See: AstarPath.debugRoof See: AstarPath.debugMode Declaration public float debugFloor Field Value Type Description Single debugMode The mode to use for drawing nodes in the sceneview. Note: Only relevant in the editor See: Pathfinding.GraphDebugMode Declaration public GraphDebugMode debugMode Field Value Type Description GraphDebugMode debugPathData The path to debug using gizmos. This is the path handler used to calculate the last path. It is used in the editor to draw debug information using gizmos. Declaration [NonSerialized] public PathHandler debugPathData Field Value Type Description PathHandler debugPathID The path ID to debug using gizmos Declaration [NonSerialized] public ushort debugPathID Field Value Type Description UInt16 debugRoof High value to use for certain AstarPath.debugMode modes. For example if AstarPath.debugMode is set to G, this value will determine when the node will be completely green. For the penalty debug mode, the nodes will be colored green when they have a penalty less than AstarPath.debugFloor and red when their penalty is greater or equal to this value and something between red and green otherwise. Note: Only relevant in the editor See: AstarPath.debugFloor See: AstarPath.debugMode Declaration public float debugRoof Field Value Type Description Single Distribution Used by the editor to guide the user to the correct place to download updates Declaration public static readonly AstarPath.AstarDistribution Distribution Field Value Type Description AstarPath.AstarDistribution euclideanEmbedding Holds settings for heuristic optimization. See: heuristic-opt (view in online documentation for working links) Declaration public EuclideanEmbedding euclideanEmbedding Field Value Type Description EuclideanEmbedding fullGetNearestSearch Do a full GetNearest search for all graphs. Additional searches will normally only be done on the graph which in the first fast search seemed to have the closest node. With this setting on, additional searches will be done on all graphs since the first check is not always completely accurate.\\n More technically: GetNearestForce on all graphs will be called if true, otherwise only on the one graph which's GetNearest search returned the best node.\\n Usually faster when disabled, but higher quality searches when enabled. When using a a navmesh or recast graph, for best quality, this setting should be combined with the Pathfinding.NavMeshGraph.accurateNearestNode setting set to true. Note: For the PointGraph this setting doesn't matter much as it has only one search mode. Declaration public bool fullGetNearestSearch Field Value Type Description Boolean graphUpdateBatchingInterval Minimum number of seconds between each batch of graph updates. If AstarPath.batchGraphUpdates is true, this defines the minimum number of seconds between each batch of graph updates. This can have a positive impact on pathfinding throughput since the pathfinding threads do not need to be stopped as often, and it reduces the overhead per graph update. All graph updates are still applied however, they are just batched together so that more of them are applied at the same time. Do not use this if you want minimal latency between a graph update being requested and it being applied. This only applies to graph updates requested using the AstarPath.UpdateGraphs(Bounds,System.Single) method. Not those requested using AstarPath.RegisterSafeUpdate(System.Action) or AstarPath.AddWorkItem(System.Action) . See: graph-updates (view in online documentation for working links) Declaration public float graphUpdateBatchingInterval Field Value Type Description Single heuristic The distance function to use as a heuristic. The heuristic, often referred to as just 'H' is the estimated cost from a node to the target. Different heuristics affect how the path picks which one to follow from multiple possible with the same length See: Pathfinding.Heuristic for more details and descriptions of the different modes. See: Wikipedia: Admissible heuristic See: Wikipedia: A* search algorithm See: Wikipedia: Dijkstra's Algorithm Declaration public Heuristic heuristic Field Value Type Description Heuristic heuristicScale The scale of the heuristic. If a value lower than 1 is used, the pathfinder will search more nodes (slower). If 0 is used, the pathfinding algorithm will be reduced to dijkstra's algorithm. This is equivalent to setting AstarPath.heuristic to None. If a value larger than 1 is used the pathfinding will (usually) be faster because it expands fewer nodes, but the paths may no longer be the optimal (i.e the shortest possible paths). Usually you should leave this to the default value of 1. See: https://en.wikipedia.org/wiki/Admissible_heuristic See: https://en.wikipedia.org/wiki/A*_search_algorithm See: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm Declaration public float heuristicScale Field Value Type Description Single logPathResults The amount of debugging messages. Use less debugging to improve performance (a bit) or just to get rid of the Console spamming. Use more debugging (heavy) if you want more information about what the pathfinding scripts are doing. The InGame option will display the latest path log using in-game GUI. [Open online documentation to see images] Declaration public PathLog logPathResults Field Value Type Description PathLog manualDebugFloorRoof If set, the AstarPath.debugFloor and AstarPath.debugRoof values will not be automatically recalculated. Note: Only relevant in the editor Declaration public bool manualDebugFloorRoof Field Value Type Description Boolean maxFrameTime Max number of milliseconds to spend each frame for pathfinding. At least 500 nodes will be searched each frame (if there are that many to search). When using multithreading this value is irrelevant. Declaration public float maxFrameTime Field Value Type Description Single maxNearestNodeDistance @name Inspector - Settings @{ Declaration public float maxNearestNodeDistance Field Value Type Description Single navmeshUpdates Handles navmesh cuts. See: Declaration public readonly NavmeshUpdates navmeshUpdates Field Value Type Description NavmeshUpdates On65KOverflow Called when pathID overflows 65536 and resets back to zero. Note: This callback will be cleared every time it is called, so if you want to register to it repeatedly, register to it directly on receiving the callback as well. Declaration public static Action On65KOverflow Field Value Type Description Action OnAwakeSettings Declaration public static Action OnAwakeSettings Field Value Type Description Action OnGraphPostScan Called for each graph after they have been scanned. All other graphs might not have been scanned yet. Declaration public static OnGraphDelegate OnGraphPostScan Field Value Type Description OnGraphDelegate OnGraphPreScan Called for each graph before they are scanned Declaration public static OnGraphDelegate OnGraphPreScan Field Value Type Description OnGraphDelegate OnGraphsUpdated Called when any graphs are updated. Register to for example recalculate the path whenever a graph changes. Declaration public static OnScanDelegate OnGraphsUpdated Field Value Type Description OnScanDelegate OnGraphsWillBeUpdated Deprecated: Declaration [Obsolete] public Action OnGraphsWillBeUpdated Field Value Type Description Action OnGraphsWillBeUpdated2 Deprecated: Declaration [Obsolete] public Action OnGraphsWillBeUpdated2 Field Value Type Description Action OnLatePostScan Called after scanning has completed fully. This is called as the last thing in the Scan function. Declaration public static OnScanDelegate OnLatePostScan Field Value Type Description OnScanDelegate OnPathPostSearch Called for each path after searching. Be careful when using multithreading since this will be called from a different thread. Declaration public static OnPathDelegate OnPathPostSearch Field Value Type Description OnPathDelegate OnPathPreSearch Called for each path before searching. Be careful when using multithreading since this will be called from a different thread. Declaration public static OnPathDelegate OnPathPreSearch Field Value Type Description OnPathDelegate OnPostScan Called after scanning. This is called before applying links, flood-filling the graphs and other post processing. Declaration public static OnScanDelegate OnPostScan Field Value Type Description OnScanDelegate OnPreScan Called before starting the scanning Declaration public static OnScanDelegate OnPreScan Field Value Type Description OnScanDelegate prioritizeGraphs Prioritize graphs. Graphs will be prioritized based on their order in the inspector. The first graph which has a node closer than AstarPath.prioritizeGraphsLimit will be chosen instead of searching all graphs. Declaration public bool prioritizeGraphs Field Value Type Description Boolean prioritizeGraphsLimit Distance limit for AstarPath.prioritizeGraphs . See: AstarPath.prioritizeGraphs Declaration public float prioritizeGraphsLimit Field Value Type Description Single scanOnStartup If true, all graphs will be scanned during Awake. This does not include loading from the cache. If you disable this, you will have to call \\link Scan AstarPath.active.Scan() \\endlink yourself to enable pathfinding. Alternatively you could load a saved graph from a file. See: AstarPath.Scan(NavGraph) See: AstarPath.ScanAsync(NavGraph) Declaration public bool scanOnStartup Field Value Type Description Boolean showGraphs Shows or hides graph inspectors. Used internally by the editor Declaration public bool showGraphs Field Value Type Description Boolean showNavGraphs @name Inspector - Debug @{ Declaration public bool showNavGraphs Field Value Type Description Boolean showSearchTree If enabled, nodes will draw a line to their 'parent'. This will show the search tree for the latest path. Note: Only relevant in the editor TODO: Add a showOnlyLastPath flag to indicate whether to draw every node or only the ones visited by the latest path. Declaration public bool showSearchTree Field Value Type Description Boolean showUnwalkableNodes Toggle to show unwalkable nodes. Note: Only relevant in the editor See: AstarPath.unwalkableNodeDebugSize Declaration public bool showUnwalkableNodes Field Value Type Description Boolean tagNames Stored tag names. See: AstarPath.FindTagNames See: AstarPath.GetTagNames Declaration protected string[] tagNames Field Value Type Description String [] threadCount Number of pathfinding threads to use. Multithreading puts pathfinding in another thread, this is great for performance on 2+ core computers since the framerate will barely be affected by the pathfinding at all. None indicates that the pathfinding is run in the Unity thread as a coroutine Automatic will try to adjust the number of threads to the number of cores and memory on the computer. Less than 512mb of memory or a single core computer will make it revert to using no multithreading. It is recommended that you use one of the \"Auto\" settings that are available. The reason is that even if your computer might be beefy and have 8 cores. Other computers might only be quad core or dual core in which case they will not benefit from more than 1 or 3 threads respectively (you usually want to leave one core for the unity thread). If you use more threads than the number of cores on the computer it is mostly just wasting memory, it will not run any faster. The extra memory usage is not trivially small. Each thread needs to keep a small amount of data for each node in all the graphs. It is not the full graph data but it is proportional to the number of nodes. The automatic settings will inspect the machine it is running on and use that to determine the number of threads so that no memory is wasted. The exception is if you only have one (or maybe two characters) active at time. Then you should probably just go with one thread always since it is very unlikely that you will need the extra throughput given by more threads. Keep in mind that more threads primarily increases throughput by calculating different paths on different threads, it will not calculate individual paths any faster. Note that if you are modifying the pathfinding core scripts or if you are directly modifying graph data without using any of the safe wrappers (like AstarPath.AddWorkItem(System.Action) multithreading can cause strange errors and pathfinding stopping to work if you are not careful. For basic usage (not modding the pathfinding core) it should be safe. Note: WebGL does not support threads at all (since javascript is single-threaded) so no threads will be used on that platform. See: CalculateThreadCount Declaration public ThreadCount threadCount Field Value Type Description ThreadCount unwalkableNodeDebugSize Size of the red cubes shown in place of unwalkable nodes. Note: Only relevant in the editor. Does not apply to grid graphs. See: AstarPath.showUnwalkableNodes Declaration public float unwalkableNodeDebugSize Field Value Type Description Single Version The version number for the A* %Pathfinding Project Declaration public static readonly Version Version Field Value Type Description Version Properties astarData Holds all graph data. Deprecated: The 'astarData' field has been renamed to 'data' Declaration [Obsolete(\"The 'astarData' field has been renamed to 'data'\")] public AstarData astarData { get; } Property Value Type Description AstarData graphs Shortcut to Pathfinding.AstarData.graphs Declaration public NavGraph[] graphs { get; } Property Value Type Description NavGraph [] graphTypes See Pathfinding.AstarData Deprecated: Declaration [Obsolete] public Type[] graphTypes { get; } Property Value Type Description Type [] IsAnyGraphUpdateInProgress Returns if any graph updates are being calculated right now. Note: This does not includes other types of work items such as navmesh cutting or anything added by AstarPath.RegisterSafeUpdate(System.Action) or AstarPath.AddWorkItem(System.Action) . See: IsAnyWorkItemInProgress Declaration public bool IsAnyGraphUpdateInProgress { get; } Property Value Type Description Boolean IsAnyGraphUpdateQueued Returns if any graph updates are waiting to be applied. Note: This is false while the updates are being performed. Note: This does not includes other types of work items such as navmesh cutting or anything added by AstarPath.RegisterSafeUpdate(System.Action) or AstarPath.AddWorkItem(System.Action) . Declaration public bool IsAnyGraphUpdateQueued { get; } Property Value Type Description Boolean IsAnyGraphUpdatesQueued Returns if any graph updates are waiting to be applied. Deprecated: Use IsAnyGraphUpdateQueued instead Declaration [Obsolete(\"Fixed grammar, use IsAnyGraphUpdateQueued instead\")] public bool IsAnyGraphUpdatesQueued { get; } Property Value Type Description Boolean IsAnyWorkItemInProgress Returns if any work items are in progress right now. Note: This includes pretty much all types of graph updates. Such as normal graph updates, navmesh cutting and anything added by AstarPath.RegisterSafeUpdate(System.Action) or AstarPath.AddWorkItem(System.Action) . Declaration public bool IsAnyWorkItemInProgress { get; } Property Value Type Description Boolean isScanning Set while any graphs are being scanned. It will be true up until the FloodFill is done. Note: Not to be confused with graph updates. Used to better support Graph Update Objects called for example in OnPostScan See: IsAnyGraphUpdateQueued See: IsAnyGraphUpdateInProgress Declaration public bool isScanning { get; } Property Value Type Description Boolean IsUsingMultithreading Returns whether or not multithreading is used. \\exception System.Exception Is thrown when it could not be decided if multithreading was used or not. This should not happen if pathfinding is set up correctly. Note: This uses info about if threads are running right now, it does not use info from the settings on the A* object. Declaration public bool IsUsingMultithreading { get; } Property Value Type Description Boolean lastScanTime The time it took for the last call to Scan() to complete. Used to prevent automatically rescanning the graphs too often (editor only) Declaration public float lastScanTime { get; } Property Value Type Description Single limitGraphUpdates Batch graph updates. Deprecated: This field has been renamed to AstarPath.batchGraphUpdates . Declaration [Obsolete(\"This field has been renamed to 'batchGraphUpdates'\")] public bool limitGraphUpdates { get; set; } Property Value Type Description Boolean maxGraphUpdateFreq Limit for how often should graphs be updated. Deprecated: This field has been renamed to AstarPath.graphUpdateBatchingInterval . Declaration [Obsolete(\"This field has been renamed to 'graphUpdateBatchingInterval'\")] public float maxGraphUpdateFreq { get; set; } Property Value Type Description Single maxNearestNodeDistanceSqr Max Nearest Node Distance Squared. See: AstarPath.maxNearestNodeDistance Declaration public float maxNearestNodeDistanceSqr { get; } Property Value Type Description Single NumParallelThreads Number of parallel pathfinders. Returns the number of concurrent processes which can calculate paths at once. When using multithreading, this will be the number of threads, if not using multithreading it is always 1 (since only 1 coroutine is used). See: IsUsingMultithreading Declaration public int NumParallelThreads { get; } Property Value Type Description Int32 Methods AddWorkItem(AstarWorkItem) Add a work item to be processed when pathfinding is paused. The work item will be executed when it is safe to update nodes. This is defined as between the path searches. When using more threads than one, calling this often might decrease pathfinding performance due to a lot of idling in the threads. Not performance as in it will use much CPU power, but performance as in the number of paths per second will probably go down (though your framerate might actually increase a tiny bit). You should only call this function from the main unity thread (i.e normal game code). AstarPath.active.AddWorkItem(new AstarWorkItem(() => { // Safe to update graphs here var node = AstarPath.active.GetNearest(transform.position).node; node.Walkable = false; })); AstarPath.active.AddWorkItem(() => { // Safe to update graphs here var node = AstarPath.active.GetNearest(transform.position).node; node.position = (Int3)transform.position; }); See: AstarPath.FlushWorkItems Declaration public void AddWorkItem(AstarWorkItem item) Parameters Type Name Description AstarWorkItem item AddWorkItem(Action) Add a work item to be processed when pathfinding is paused. Convenience method that is equivalent to AddWorkItem(new AstarWorkItem(callback)); See: AstarPath.AddWorkItem(AstarWorkItem) Declaration public void AddWorkItem(Action callback) Parameters Type Name Description Action callback AddWorkItem(Action<IWorkItemContext>) Add a work item to be processed when pathfinding is paused. Convenience method that is equivalent to AddWorkItem(new AstarWorkItem(callback)); See: AstarPath.AddWorkItem(AstarWorkItem) Declaration public void AddWorkItem(Action<IWorkItemContext> callback) Parameters Type Name Description Action < IWorkItemContext > callback Awake() Sets up all needed variables and scans the graphs. Calls Initialize, starts the ReturnPaths coroutine and scans all graphs. Also starts threads if using multithreading See: AstarPath.OnAwakeSettings Declaration protected override void Awake() BlockUntilCalculated(Path) Blocks until the path has been calculated. Normally it takes a few frames for a path to be calculated and returned. This function will ensure that the path will be calculated when this function returns and that the callback for that path has been called. If requesting a lot of paths in one go and waiting for the last one to complete, it will calculate most of the paths in the queue (only most if using multithreading, all if not using multithreading). Use this function only if you really need to. There is a point to spreading path calculations out over several frames. It smoothes out the framerate and makes sure requesting a large number of paths at the same time does not cause lag. Note: Graph updates and other callbacks might get called during the execution of this function. When the pathfinder is shutting down. I.e in OnDestroy, this function will not do anything. \\throws Exception if pathfinding is not initialized properly for this scene (most likely no AstarPath object exists) or if the path has not been started yet. Also throws an exception if critical errors occur such as when the pathfinding threads have crashed (which should not happen in normal cases). This prevents an infinite loop while waiting for the path. See: Pathfinding.Path.WaitForPath See: Pathfinding.Path.BlockUntilCalculated Declaration public static void BlockUntilCalculated(Path path) Parameters Type Name Description Path path The path to wait for. The path must be started, otherwise an exception will be thrown. BlockUntilPathQueueBlocked() Blocks until all pathfinding threads are paused and blocked. Deprecated: Use AstarPath.PausePathfinding instead. Make sure to call Release on the returned lock. Declaration [Obsolete(\"Use PausePathfinding instead. Make sure to call Release on the returned lock.\", true)] public void BlockUntilPathQueueBlocked() CalculateThreadCount(ThreadCount) Declaration public static int CalculateThreadCount(ThreadCount count) Parameters Type Name Description ThreadCount count Returns Type Description Int32 ConfigureReferencesInternal() \\cond internal Declaration public void ConfigureReferencesInternal() EnsureValidFloodFill() If a WorkItem needs to have a valid flood fill during execution, call this method to ensure there are no pending flood fills. Deprecated: This method has been moved. Use the method on the context object that can be sent with work item delegates instead AstarPath.active.AddWorkItem(new AstarWorkItem(() => { // Safe to update graphs here var node = AstarPath.active.GetNearest(transform.position).node; node.Walkable = false; })); See: Pathfinding.IWorkItemContext Declaration [Obsolete(\"This method has been moved. Use the method on the context object that can be sent with work item delegates instead\")] public void EnsureValidFloodFill() FindAstarPath() Used outside of play mode to initialize the AstarPath object even if it has not been selected in the inspector yet. This will set the AstarPath.active property and deserialize all graphs. This is useful if you want to do changes to the graphs in the editor outside of play mode, but cannot be sure that the graphs have been deserialized yet. In play mode this method does nothing. Declaration public static void FindAstarPath() FindTagNames() Tries to find an AstarPath object and return tag names. If an AstarPath object cannot be found, it returns an array of length 1 with an error message. See: AstarPath.GetTagNames Declaration public static string[] FindTagNames() Returns Type Description String [] FloodFill() Floodfills all graphs and updates areas for every node. The different colored areas that you see in the scene view when looking at graphs are called just 'areas', this method calculates which nodes are in what areas. See: Pathfinding.Node.area Deprecated: Avoid using. This will force a full recalculation of the connected components. In most cases the HierarchicalGraph class takes care of things automatically behind the scenes now. Declaration [Obsolete(\"Avoid using. This will force a full recalculation of the connected components. In most cases the HierarchicalGraph class takes care of things automatically behind the scenes now.\")] public void FloodFill() FloodFill(GraphNode) Floodfills starting from the specified node. Deprecated: Deprecated: Not meaningful anymore. The HierarchicalGraph takes care of things automatically behind the scenes Declaration [Obsolete(\"Not meaningful anymore. The HierarchicalGraph takes care of things automatically behind the scenes\")] public void FloodFill(GraphNode seed) Parameters Type Name Description GraphNode seed FloodFill(GraphNode, UInt32) Floodfills starting from 'seed' using the specified area. Deprecated: Not meaningful anymore. The HierarchicalGraph takes care of things automatically behind the scenes Declaration [Obsolete(\"Not meaningful anymore. The HierarchicalGraph takes care of things automatically behind the scenes\")] public void FloodFill(GraphNode seed, uint area) Parameters Type Name Description GraphNode seed UInt32 area FlushGraphUpdates() Forces graph updates to complete in a single frame. This will force the pathfinding threads to finish calculating the path they are currently calculating (if any) and then pause. When all threads have paused, graph updates will be performed. Warning: Using this very often (many times per second) can reduce your fps due to a lot of threads waiting for one another. But you probably wont have to worry about that. Note: This is almost identical to AstarPath.FlushWorkItems , but added for more descriptive name. This function will also override any time limit delays for graph updates. This is because graph updates are implemented using work items. So calling this function will also execute any other work items (if any are queued). Will not do anything if there are no graph updates queued (not even execute other work items). Declaration public void FlushGraphUpdates() FlushThreadSafeCallbacks() Forces thread safe callbacks to run. Deprecated: Use AstarPath.FlushWorkItems instead Declaration [Obsolete(\"Use FlushWorkItems instead\")] public void FlushThreadSafeCallbacks() FlushWorkItems() Forces work items to complete in a single frame. This will force all work items to run immidiately. This will force the pathfinding threads to finish calculating the path they are currently calculating (if any) and then pause. When all threads have paused, work items will be executed (which can be e.g graph updates). Warning: Using this very often (many times per second) can reduce your fps due to a lot of threads waiting for one another. But you probably wont have to worry about that Note: This is almost (note almost) identical to AstarPath.FlushGraphUpdates , but added for more descriptive name. Will not do anything if there are no queued work items waiting to run. Declaration public void FlushWorkItems() FlushWorkItems(Boolean, Boolean) Make sure work items are executed. See: AddWorkItem Deprecated: Use AstarPath.FlushWorkItems instead. Declaration [Obsolete(\"Use FlushWorkItems() instead\")] public void FlushWorkItems(bool unblockOnComplete, bool block) Parameters Type Name Description Boolean unblockOnComplete If true, pathfinding will be allowed to start running immediately after completing all work items. Boolean block If true, work items that usually take more than one frame to complete will be forced to complete during this call. If false, then after this call there might still be work left to do. GetNearest(Ray) Returns the node closest to the ray (slow). Warning: This function is brute-force and very slow, use with caution Declaration public GraphNode GetNearest(Ray ray) Parameters Type Name Description Ray ray Returns Type Description GraphNode GetNearest(Vector3) Returns the nearest node to a position using the specified NNConstraint. Searches through all graphs for their nearest nodes to the specified position and picks the closest one.\\n Using the NNConstraint.None constraint. // Find the closest node to this GameObject's position GraphNode node = AstarPath.active.GetNearest(transform.position).node; if (node.Walkable) { // Yay, the node is walkable, we can place a tower here or something } See: Pathfinding.NNConstraint Declaration public NNInfo GetNearest(Vector3 position) Parameters Type Name Description Vector3 position Returns Type Description NNInfo GetNearest(Vector3, NNConstraint) Declaration public NNInfo GetNearest(Vector3 position, NNConstraint constraint) Parameters Type Name Description Vector3 position NNConstraint constraint Returns Type Description NNInfo GetNearest(Vector3, NNConstraint, GraphNode) Returns the nearest node to a position using the specified NNConstraint. Searches through all graphs for their nearest nodes to the specified position and picks the closest one. The NNConstraint can be used to specify constraints on which nodes can be chosen such as only picking walkable nodes. See: Pathfinding.NNConstraint Declaration public NNInfo GetNearest(Vector3 position, NNConstraint constraint, GraphNode hint) Parameters Type Name Description Vector3 position NNConstraint constraint GraphNode hint Returns Type Description NNInfo GetTagNames() Returns tag names. Makes sure that the tag names array is not null and of length 32. If it is null or not of length 32, it creates a new array and fills it with 0,1,2,3,4 etc... See: AstarPath.FindTagNames Declaration public string[] GetTagNames() Returns Type Description String [] PausePathfinding() Blocks until all pathfinding threads are paused and blocked. var graphLock = AstarPath.active.PausePathfinding(); // Here we can modify the graphs safely. For example by adding a new node to a point graph var node = AstarPath.active.data.pointGraph.AddNode((Int3) new Vector3(3, 1, 4)); // Allow pathfinding to resume graphLock.Release(); Returns: A lock object. You need to call Pathfinding.PathProcessor.GraphUpdateLock.Release on that object to allow pathfinding to resume. Note: In most cases this should not be called from user code. Use the AstarPath.AddWorkItem(System.Action) method instead. See: AstarPath.AddWorkItem(System.Action) Declaration public PathProcessor.GraphUpdateLock PausePathfinding() Returns Type Description PathProcessor.GraphUpdateLock QueueGraphUpdates() Will apply queued graph updates as soon as possible, regardless of AstarPath.batchGraphUpdates . Calling this multiple times will not create multiple callbacks. This function is useful if you are limiting graph updates, but you want a specific graph update to be applied as soon as possible regardless of the time limit. Note that this does not block until the updates are done, it merely bypasses the AstarPath.batchGraphUpdates time limit. See: AstarPath.FlushGraphUpdates Declaration public void QueueGraphUpdates() QueueWorkItemFloodFill() Call during work items to queue a flood fill. Deprecated: This method has been moved. Use the method on the context object that can be sent with work item delegates instead AstarPath.active.AddWorkItem(new AstarWorkItem(() => { // Safe to update graphs here var node = AstarPath.active.GetNearest(transform.position).node; node.Walkable = false; })); See: Pathfinding.IWorkItemContext Declaration [Obsolete(\"This method has been moved. Use the method on the context object that can be sent with work item delegates instead\")] public void QueueWorkItemFloodFill() RegisterSafeUpdate(Action) Will send a callback when it is safe to update nodes. This is defined as between the path searches. This callback will only be sent once and is nulled directly after the callback has been sent. When using more threads than one, calling this often might decrease pathfinding performance due to a lot of idling in the threads. Not performance as in it will use much CPU power, but performance as in the number of paths per second will probably go down (though your framerate might actually increase a tiny bit) You should only call this function from the main unity thread (i.e normal game code). Version: Since version 4.0 this is equivalent to AddWorkItem(new AstarWorkItem(callback)). Previously the callbacks added using this method would not be ordered with respect to other work items, so they could be executed before other work items or after them. Deprecated: Use AstarPath.AddWorkItem(System.Action) instead. Note the slight change in behavior (mentioned above). Declaration [Obsolete(\"Use AddWorkItem(System.Action) instead. Note the slight change in behavior (mentioned in the documentation).\")] public static void RegisterSafeUpdate(Action callback) Parameters Type Name Description Action callback Scan(NavGraph) Scans a particular graph. Calling this method will recalculate the specified graph. This method is pretty slow (depending on graph type and graph complexity of course), so it is advisable to use smaller graph updates whenever possible. // Recalculate all graphs AstarPath.active.Scan(); // Recalculate only the first grid graph var graphToScan = AstarPath.active.data.gridGraph; AstarPath.active.Scan(graphToScan); // Recalculate only the first and third graphs var graphsToScan = new [] { AstarPath.active.data.graphs[0], AstarPath.active.data.graphs[2] }; AstarPath.active.Scan(graphsToScan); See: graph-updates (view in online documentation for working links) See: ScanAsync Declaration public void Scan(NavGraph graphToScan) Parameters Type Name Description NavGraph graphToScan Scan(NavGraph[]) Scans all specified graphs. Calling this method will recalculate all specified graphs or all graphs if the graphsToScan parameter is null. This method is pretty slow (depending on graph type and graph complexity of course), so it is advisable to use smaller graph updates whenever possible. // Recalculate all graphs AstarPath.active.Scan(); // Recalculate only the first grid graph var graphToScan = AstarPath.active.data.gridGraph; AstarPath.active.Scan(graphToScan); // Recalculate only the first and third graphs var graphsToScan = new [] { AstarPath.active.data.graphs[0], AstarPath.active.data.graphs[2] }; AstarPath.active.Scan(graphsToScan); See: graph-updates (view in online documentation for working links) See: ScanAsync Declaration public void Scan(NavGraph[] graphsToScan = null) Parameters Type Name Description NavGraph [] graphsToScan The graphs to scan. If this parameter is null then all graphs will be scanned ScanAsync(NavGraph) Scans a particular graph asynchronously. This is a IEnumerable, you can loop through it to get the progress foreach (Progress progress in AstarPath.active.ScanAsync()) { Debug.Log(\"Scanning... \" + progress.description + \" - \" + (progress.progress*100).ToString(\"0\") + \"%\"); } You can scan graphs asyncronously by yielding when you loop through the progress. Note that this does not guarantee a good framerate, but it will allow you to at least show a progress bar during scanning. IEnumerator Start () { foreach (Progress progress in AstarPath.active.ScanAsync()) { Debug.Log(\"Scanning... \" + progress.description + \" - \" + (progress.progress*100).ToString(\"0\") + \"%\"); yield return null; } } See: Scan Declaration public IEnumerable<Progress> ScanAsync(NavGraph graphToScan) Parameters Type Name Description NavGraph graphToScan Returns Type Description System.Collections.IEnumerable < Progress > ScanAsync(NavGraph[]) Scans all specified graphs asynchronously. This is a IEnumerable, you can loop through it to get the progress foreach (Progress progress in AstarPath.active.ScanAsync()) { Debug.Log(\"Scanning... \" + progress.description + \" - \" + (progress.progress*100).ToString(\"0\") + \"%\"); } You can scan graphs asyncronously by yielding when you loop through the progress. Note that this does not guarantee a good framerate, but it will allow you to at least show a progress bar during scanning. IEnumerator Start () { foreach (Progress progress in AstarPath.active.ScanAsync()) { Debug.Log(\"Scanning... \" + progress.description + \" - \" + (progress.progress*100).ToString(\"0\") + \"%\"); yield return null; } } See: Scan Declaration public IEnumerable<Progress> ScanAsync(NavGraph[] graphsToScan = null) Parameters Type Name Description NavGraph [] graphsToScan The graphs to scan. If this parameter is null then all graphs will be scanned Returns Type Description System.Collections.IEnumerable < Progress > StartPath(Path, Boolean) Adds the path to a queue so that it will be calculated as soon as possible. The callback specified when constructing the path will be called when the path has been calculated. Usually you should use the Seeker component instead of calling this function directly. Declaration public static void StartPath(Path path, bool pushToFront = false) Parameters Type Name Description Path path The path that should be enqueued. Boolean pushToFront If true, the path will be pushed to the front of the queue, bypassing all waiting paths and making it the next path to be calculated. This can be useful if you have a path which you want to prioritize over all others. Be careful to not overuse it though. If too many paths are put in the front of the queue often, this can lead to normal paths having to wait a very long time before being calculated. UpdateGraphs(Bounds) Update all graphs within bounds. The graphs will be updated as soon as possible. This is equivalent to UpdateGraphs(new GraphUpdateObject(bounds)); See: FlushGraphUpdates See: batchGraphUpdates See: graph-updates (view in online documentation for working links) Declaration public void UpdateGraphs(Bounds bounds) Parameters Type Name Description Bounds bounds UpdateGraphs(Bounds, Single) Update all graphs within bounds after delay seconds. The graphs will be updated as soon as possible. See: FlushGraphUpdates See: batchGraphUpdates See: graph-updates (view in online documentation for working links) Declaration public void UpdateGraphs(Bounds bounds, float delay) Parameters Type Name Description Bounds bounds Single delay UpdateGraphs(GraphUpdateObject) Update all graphs using the GraphUpdateObject. This can be used to, e.g make all nodes in a region unwalkable, or set them to a higher penalty. The graphs will be updated as soon as possible (with respect to AstarPath.batchGraphUpdates See: FlushGraphUpdates See: batchGraphUpdates See: graph-updates (view in online documentation for working links) Declaration public void UpdateGraphs(GraphUpdateObject ob) Parameters Type Name Description GraphUpdateObject ob UpdateGraphs(GraphUpdateObject, Single) Update all graphs using the GraphUpdateObject after delay seconds. This can be used to, e.g make all nodes in a region unwalkable, or set them to a higher penalty. See: FlushGraphUpdates See: batchGraphUpdates See: graph-updates (view in online documentation for working links) Declaration public void UpdateGraphs(GraphUpdateObject ob, float delay) Parameters Type Name Description GraphUpdateObject ob Single delay WaitForPath(Path) Wait for the specified path to be calculated. Normally it takes a few frames for a path to get calculated and returned. Deprecated: This method has been renamed to AstarPath.BlockUntilCalculated(Path) . Declaration [Obsolete(\"This method has been renamed to BlockUntilCalculated\")] public static void WaitForPath(Path path) Parameters Type Name Description Path path"
  },
  "api/Global.AttackableAttacker.html": {
    "href": "api/Global.AttackableAttacker.html",
    "title": "Class AttackableAttacker | Morpy",
    "keywords": "Class AttackableAttacker Inheritance Object AttackableAttacker Namespace : Global Assembly : cs.temp.dll.dll Syntax public class AttackableAttacker : MonoBehaviour Fields attackButton Declaration public GameObject attackButton Field Value Type Description GameObject attackRange Declaration public float attackRange Field Value Type Description Single cooldownTimeInSeconds Declaration public float cooldownTimeInSeconds Field Value Type Description Single enemyAttackDelay Declaration public float enemyAttackDelay Field Value Type Description Single mass Declaration public float mass Field Value Type Description Single nearAttackRange Declaration public float nearAttackRange Field Value Type Description Single Methods attack(GameObject) Declaration public void attack(GameObject go) Parameters Type Name Description GameObject go attackNearest() Declaration public void attackNearest() attackNearestWithCustomAction() Declaration public void attackNearestWithCustomAction() attackWithCustomAction(GameObject) Declaration public void attackWithCustomAction(GameObject go) Parameters Type Name Description GameObject go calculateDistanceToObject(GameObject) Declaration public float calculateDistanceToObject(GameObject go) Parameters Type Name Description GameObject go Returns Type Description Single getAttacked(GameObject, Int32) Declaration public void getAttacked(GameObject attacker, int strength) Parameters Type Name Description GameObject attacker Int32 strength getEnemyTag() Declaration public string getEnemyTag() Returns Type Description String getIsInCooldown() Declaration public bool getIsInCooldown() Returns Type Description Boolean getNearestEnemy() Declaration public GameObject getNearestEnemy() Returns Type Description GameObject"
  },
  "api/Global.AttackEntersLeavesCooldown.html": {
    "href": "api/Global.AttackEntersLeavesCooldown.html",
    "title": "Class AttackEntersLeavesCooldown | Morpy",
    "keywords": "Class AttackEntersLeavesCooldown Inheritance Object EventManager.Event EventManager.Event < AttackEntersLeavesCooldown > AttackEntersLeavesCooldown Inherited Members EventManager.Event<AttackEntersLeavesCooldown>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class AttackEntersLeavesCooldown : EventManager.Event<AttackEntersLeavesCooldown>, IComparable<EventManager.Event> Fields attackButton Declaration public GameObject attackButton Field Value Type Description GameObject isInCooldown Declaration public bool isInCooldown Field Value Type Description Boolean Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.AudioManager.html": {
    "href": "api/Global.AudioManager.html",
    "title": "Class AudioManager | Morpy",
    "keywords": "Class AudioManager Inheritance Object AudioManager Namespace : Global Assembly : cs.temp.dll.dll Syntax public class AudioManager : MonoBehaviour Fields instance Current AudioManager interface. Needed to enforce singeton behaviour Declaration public static AudioManager instance Field Value Type Description AudioManager mixerGroup Unity Audio Mixer Group Declaration public AudioMixerGroup mixerGroup Field Value Type Description AudioMixerGroup sounds A list of sounds that can be played during the game Declaration public Sound[] sounds Field Value Type Description Sound [] Methods Play(String) Play a sound using the AudioManager Declaration public void Play(string sound) Parameters Type Name Description String sound Name of the sound as defined in the Sounds array"
  },
  "api/Global.CameraController.html": {
    "href": "api/Global.CameraController.html",
    "title": "Class CameraController | Morpy",
    "keywords": "Class CameraController Inheritance Object CameraController Namespace : Global Assembly : cs.temp.dll.dll Syntax public class CameraController : MonoBehaviour Fields Direction Declaration public RoateDirection Direction Field Value Type Description RoateDirection rotate Declaration public bool rotate Field Value Type Description Boolean virtualCamera Declaration public Cinemachine.CinemachineVirtualCamera virtualCamera Field Value Type Description Cinemachine.CinemachineVirtualCamera"
  },
  "api/Global.CharacterType.html": {
    "href": "api/Global.CharacterType.html",
    "title": "Enum CharacterType | Morpy",
    "keywords": "Enum CharacterType Namespace : Global Assembly : cs.temp.dll.dll Syntax public enum CharacterType Fields Name Description Bee Bunny NotSpecified Rhino Slime Snail"
  },
  "api/Global.DeathZone.html": {
    "href": "api/Global.DeathZone.html",
    "title": "Class DeathZone | Morpy",
    "keywords": "Class DeathZone Inheritance Object DeathZone Namespace : Global Assembly : cs.temp.dll.dll Syntax public class DeathZone : MonoBehaviour"
  },
  "api/Global.EnablePlayerInput.html": {
    "href": "api/Global.EnablePlayerInput.html",
    "title": "Class EnablePlayerInput | Morpy",
    "keywords": "Class EnablePlayerInput Inheritance Object EventManager.Event EventManager.Event < EnablePlayerInput > EnablePlayerInput Inherited Members EventManager.Event<EnablePlayerInput>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class EnablePlayerInput : EventManager.Event<EnablePlayerInput>, IComparable<EventManager.Event> Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.EnemyAI.html": {
    "href": "api/Global.EnemyAI.html",
    "title": "Class EnemyAI | Morpy",
    "keywords": "Class EnemyAI Class defining the behaviour of hostile entities Inheritance Object EnemyAI Namespace : Global Assembly : cs.temp.dll.dll Syntax public class EnemyAI : MonoBehaviour Fields activateDistance Defines how far the player has to be away for the character to start moving. Declaration public float activateDistance Field Value Type Description Single animator The animation object which is used to animate the character. Declaration public Animator animator Field Value Type Description Animator bunnySpecialAttackDelay Declaration public float bunnySpecialAttackDelay Field Value Type Description Single characterType Defines what kind of character the AI has. Declaration public CharacterType characterType Field Value Type Description CharacterType directionLookEnabled Defines if the charakter looks into the direction it is going into. Declaration public bool directionLookEnabled Field Value Type Description Boolean followEnabled The layer on which the playes is on. Declaration public bool followEnabled Field Value Type Description Boolean gravityDown Defines if the character should walk on the flor or the ceiling. Declaration public bool gravityDown Field Value Type Description Boolean jumpCheckOffset Defines a little bit of wiggle-room to decide if the character touches the ground or not. Declaration public float jumpCheckOffset Field Value Type Description Single jumpEnabled Defines if the charakter is able to jump. Declaration public bool jumpEnabled Field Value Type Description Boolean jumpModifier Defines the multiplier that gets applied into the y-direction if a charakter jumps. Declaration public float jumpModifier Field Value Type Description Single jumpNodeHeightRequirement Defines at which height-differenc of the path the charakter should attempt jumping. Declaration public float jumpNodeHeightRequirement Field Value Type Description Single nextWaypointDistance Defines at which point a new Waypoint should be used to follow the path. Declaration public float nextWaypointDistance Field Value Type Description Single pathUpdateSeconds Defines how often the path should be recalculated. Declaration public float pathUpdateSeconds Field Value Type Description Single platformLayerMask The layer on which the charakter should move on. Declaration public LayerMask platformLayerMask Field Value Type Description LayerMask playerLayerMask Declaration public LayerMask playerLayerMask Field Value Type Description LayerMask speed Declaration public float speed Field Value Type Description Single target Declaration public Transform target Field Value Type Description Transform Methods Jump() Makes the charakter jump by applying an upwards force. Declaration public void Jump() Run() Makes a charakter run by multiplying its force in the x-direction. Declaration public void Run() Start() Initializes AI by getting all necessary components, turning the gravity if nexessary and starting to compute paths. Declaration public void Start()"
  },
  "api/Global.EnemyAI.MovementState.html": {
    "href": "api/Global.EnemyAI.MovementState.html",
    "title": "Enum EnemyAI.MovementState | Morpy",
    "keywords": "Enum EnemyAI.MovementState The different kind of states of movement a charakter can be in. Namespace : Global Assembly : cs.temp.dll.dll Syntax public enum MovementState Fields Name Description Sprinting Standing Walking"
  },
  "api/Global.EnemyArtifact.html": {
    "href": "api/Global.EnemyArtifact.html",
    "title": "Class EnemyArtifact | Morpy",
    "keywords": "Class EnemyArtifact Inheritance Object EnemyArtifact Namespace : Global Assembly : cs.temp.dll.dll Syntax public class EnemyArtifact : MonoBehaviour Fields characterType Declaration public CharacterType characterType Field Value Type Description CharacterType"
  },
  "api/Global.EnemyArtifactSpawner.html": {
    "href": "api/Global.EnemyArtifactSpawner.html",
    "title": "Class EnemyArtifactSpawner | Morpy",
    "keywords": "Class EnemyArtifactSpawner Inheritance Object EnemyArtifactSpawner Namespace : Global Assembly : cs.temp.dll.dll Syntax public class EnemyArtifactSpawner : MonoBehaviour Fields enemyBunnyArtifactPrefab Declaration public Transform enemyBunnyArtifactPrefab Field Value Type Description Transform enemyRhinoArtifactPrefab Declaration public Transform enemyRhinoArtifactPrefab Field Value Type Description Transform enemySlimeArtifactPrefab Declaration public Transform enemySlimeArtifactPrefab Field Value Type Description Transform Methods SpawnArtifact(CharacterType, Vector3) Declaration public void SpawnArtifact(CharacterType characterType, Vector3 position) Parameters Type Name Description CharacterType characterType Vector3 position"
  },
  "api/Global.EnemyDeath.html": {
    "href": "api/Global.EnemyDeath.html",
    "title": "Class EnemyDeath | Morpy",
    "keywords": "Class EnemyDeath Inheritance Object EventManager.Event EventManager.Event < HealthIsZero > EnemyDeath Inherited Members EventManager.Event<HealthIsZero>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class EnemyDeath : EventManager.Event<HealthIsZero>, IComparable<EventManager.Event> Fields gameObject Declaration public GameObject gameObject Field Value Type Description GameObject Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.EventManager.Event.html": {
    "href": "api/Global.EventManager.Event.html",
    "title": "Class EventManager.Event | Morpy",
    "keywords": "Class EventManager.Event An event is something that happens at a point in time in a simulation. The Precondition method is used to check if the event should be executed, as conditions may have changed in the simulation since the event was originally scheduled. Inheritance Object EventManager.Event EventManager.Event<T> Namespace : Global Assembly : cs.temp.dll.dll Syntax public abstract class Event : IComparable<EventManager.Event> Methods CompareTo(EventManager.Event) Declaration public int CompareTo(EventManager.Event other) Parameters Type Name Description EventManager.Event other Returns Type Description Int32 Execute() Declaration public abstract void Execute() Precondition() Declaration public virtual bool Precondition() Returns Type Description Boolean"
  },
  "api/Global.EventManager.Event-1.html": {
    "href": "api/Global.EventManager.Event-1.html",
    "title": "Class EventManager.Event<T> | Morpy",
    "keywords": "Class EventManager.Event<T> Inheritance Object EventManager.Event EventManager.Event<T> AttackEntersLeavesCooldown EnablePlayerInput EnemyDeath HealthIsZero LoadLevel MorphPlayer PlayerDeath PlayerEnteredDeathZone PlayerEnteredGoal PlayerSpawn RotateWorld Inherited Members EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Execute() EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public abstract class Event<T> : EventManager.Event, IComparable<EventManager.Event> where T : EventManager.Event<T> Type Parameters Name Description T Fields OnExecute Declaration public static Action<T> OnExecute Field Value Type Description Action <T>"
  },
  "api/Global.EventManager.html": {
    "href": "api/Global.EventManager.html",
    "title": "Class EventManager | Morpy",
    "keywords": "Class EventManager The Simulation class implements the discrete event simulator pattern. Events are pooled, with a default capacity of 4 instances. Inheritance Object EventManager Namespace : Global Assembly : cs.temp.dll.dll Syntax public static class EventManager Methods Clear() Clear all pending events and reset the tick to 0. Declaration public static void Clear() DestroyModel<T>() Destroy the simulation model instance for a class. Declaration public static void DestroyModel<T>() where T : class, new() Type Parameters Name Description T GetModel<T>() Return the simulation model instance for a class. Declaration public static T GetModel<T>() where T : class, new() Returns Type Description T Type Parameters Name Description T New<T>() Create a new event of type T and return it, but do not schedule it. Declaration public static T New<T>() where T : EventManager.Event, new() Returns Type Description T Type Parameters Name Description T Reschedule<T>(T, Single) Reschedule an existing event for a future tick, and return it. Declaration public static T Reschedule<T>(T ev, float tick) where T : EventManager.Event, new() Parameters Type Name Description T ev Single tick Tick. Returns Type Description T The event. Type Parameters Name Description T The event type parameter. Schedule<T>(Single) Schedule an event for a future tick, and return it. Declaration public static T Schedule<T>(float tick = 0F) where T : EventManager.Event, new() Parameters Type Name Description Single tick Tick. Returns Type Description T The event. Type Parameters Name Description T The event type parameter. SetModel<T>(T) Set a simulation model instance for a class. Declaration public static void SetModel<T>(T instance) where T : class, new() Parameters Type Name Description T instance Type Parameters Name Description T Tick() Tick the simulation. Returns the count of remaining events. If remaining events is zero, the simulation is finished unless events are injected from an external system via a Schedule() call. Declaration public static int Tick() Returns Type Description Int32"
  },
  "api/Global.GameController.html": {
    "href": "api/Global.GameController.html",
    "title": "Class GameController | Morpy",
    "keywords": "Class GameController Inheritance Object GameController Namespace : Global Assembly : cs.temp.dll.dll Syntax public class GameController : MonoBehaviour Fields model Declaration public PlatformerModel model Field Value Type Description PlatformerModel Properties Instance Declaration public static GameController Instance { get; } Property Value Type Description GameController"
  },
  "api/Global.GoalZone.html": {
    "href": "api/Global.GoalZone.html",
    "title": "Class GoalZone | Morpy",
    "keywords": "Class GoalZone Inheritance Object GoalZone Namespace : Global Assembly : cs.temp.dll.dll Syntax public class GoalZone : MonoBehaviour"
  },
  "api/Global.Health.html": {
    "href": "api/Global.Health.html",
    "title": "Class Health | Morpy",
    "keywords": "Class Health Inheritance Object Health Namespace : Global Assembly : cs.temp.dll.dll Syntax public class Health : MonoBehaviour Fields currentHp Declaration public int currentHp Field Value Type Description Int32 healthBarPrefab Declaration public GameObject healthBarPrefab Field Value Type Description GameObject maxHP Declaration public int maxHP Field Value Type Description Int32 Properties IsAlive Declaration public bool IsAlive { get; } Property Value Type Description Boolean Methods Decrement(Int32) Declaration public void Decrement(int amount = 1) Parameters Type Name Description Int32 amount Die() Declaration public void Die() Increment(Int32) Declaration public void Increment(int amount = 1) Parameters Type Name Description Int32 amount SetMaxHealth() Declaration public void SetMaxHealth()"
  },
  "api/Global.HealthBarController.html": {
    "href": "api/Global.HealthBarController.html",
    "title": "Class HealthBarController | Morpy",
    "keywords": "Class HealthBarController Inheritance Object HealthBarController Namespace : Global Assembly : cs.temp.dll.dll Syntax public class HealthBarController : MonoBehaviour"
  },
  "api/Global.HealthIsZero.html": {
    "href": "api/Global.HealthIsZero.html",
    "title": "Class HealthIsZero | Morpy",
    "keywords": "Class HealthIsZero Inheritance Object EventManager.Event EventManager.Event < HealthIsZero > HealthIsZero Inherited Members EventManager.Event<HealthIsZero>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class HealthIsZero : EventManager.Event<HealthIsZero>, IComparable<EventManager.Event> Fields gameObject Declaration public GameObject gameObject Field Value Type Description GameObject Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.HeapQueue-1.html": {
    "href": "api/Global.HeapQueue-1.html",
    "title": "Class HeapQueue<T> | Morpy",
    "keywords": "Class HeapQueue<T> Inheritance Object HeapQueue<T> Namespace : Global Assembly : cs.temp.dll.dll Syntax public class HeapQueue<T> where T : IComparable<T> Type Parameters Name Description T Constructors HeapQueue() Declaration public HeapQueue() Properties Count Declaration public int Count { get; } Property Value Type Description Int32 First Declaration public T First { get; } Property Value Type Description T IsEmpty Declaration public bool IsEmpty { get; } Property Value Type Description Boolean Methods Clear() Declaration public void Clear() Contains(T) Declaration public bool Contains(T item) Parameters Type Name Description T item Returns Type Description Boolean Peek() Declaration public T Peek() Returns Type Description T Pop() Declaration public T Pop() Returns Type Description T Push(T) Declaration public void Push(T item) Parameters Type Name Description T item Remove(T) Declaration public void Remove(T item) Parameters Type Name Description T item"
  },
  "api/Global.HighscoreController.html": {
    "href": "api/Global.HighscoreController.html",
    "title": "Class HighscoreController | Morpy",
    "keywords": "Class HighscoreController Inheritance Object HighscoreController Namespace : Global Assembly : cs.temp.dll.dll Syntax public class HighscoreController : MonoBehaviour Methods CheckTimeIsNewHighScore(TimeSpan) Declaration public bool CheckTimeIsNewHighScore(TimeSpan timeSpan) Parameters Type Name Description TimeSpan timeSpan Returns Type Description Boolean GetCurrentTime() Declaration public TimeSpan GetCurrentTime() Returns Type Description TimeSpan GetSavedHighScore() Declaration public TimeSpan GetSavedHighScore() Returns Type Description TimeSpan SaveHighScore(TimeSpan) Declaration public static void SaveHighScore(TimeSpan timeSpan) Parameters Type Name Description TimeSpan timeSpan StartMeasurement() Declaration public void StartMeasurement()"
  },
  "api/Global.html": {
    "href": "api/Global.html",
    "title": "Namespace Global | Morpy",
    "keywords": "Namespace Global Classes AstarPath AttackableAttacker AttackEntersLeavesCooldown AudioManager CameraController DeathZone EnablePlayerInput EnemyAI Class defining the behaviour of hostile entities EnemyArtifact EnemyArtifactSpawner EnemyDeath EventManager The Simulation class implements the discrete event simulator pattern. Events are pooled, with a default capacity of 4 instances. EventManager.Event An event is something that happens at a point in time in a simulation. The Precondition method is used to check if the event should be executed, as conditions may have changed in the simulation since the event was originally scheduled. EventManager.Event<T> GameController GoalZone Health HealthBarController HealthIsZero HeapQueue<T> HighscoreController KinematicObject Implements game physics for some in game entity. LevelController LoadLevel MainMenuScript MorphPlayer PauseMenuScript PlatformerModel PlayerController PlayerDeath PlayerEnteredDeathZone PlayerEnteredGoal PlayerSpawn RotateToGravity Class for rotating an object with the gravity acting on the device. RotateWorld Sound An audio clip for the Audio Manager SpawnPoint Enums AstarPath.AstarDistribution Information about where the package was downloaded CharacterType EnemyAI.MovementState The different kind of states of movement a charakter can be in. PlayerController.JumpState PlayerController.MovementState RoateDirection"
  },
  "api/Global.KinematicObject.html": {
    "href": "api/Global.KinematicObject.html",
    "title": "Class KinematicObject | Morpy",
    "keywords": "Class KinematicObject Implements game physics for some in game entity. Inheritance Object KinematicObject PlayerController Namespace : Global Assembly : cs.temp.dll.dll Syntax public class KinematicObject : MonoBehaviour Fields gravityModifier A custom gravity coefficient applied to this entity. Declaration public float gravityModifier Field Value Type Description Single Invert Declaration protected int Invert Field Value Type Description Int32 invertedMovement The current velocity of the entity. Declaration public bool invertedMovement Field Value Type Description Boolean minGroundNormalY The minimum normal (dot product) considered suitable for the entity sit on. Declaration public float minGroundNormalY Field Value Type Description Single TargetVelocity Declaration protected Vector2 TargetVelocity Field Value Type Description Vector2 velocity The current velocity of the entity. Declaration public Vector2 velocity Field Value Type Description Vector2 Properties IsGrounded Is the entity currently sitting on a surface? Declaration protected bool IsGrounded { get; } Property Value Type Description Boolean Methods Bounce(Single) Bounce the object's vertical velocity. Declaration public void Bounce(float value) Parameters Type Name Description Single value Bounce(Vector2) Bounce the objects velocity in a direction. Declaration public void Bounce(Vector2 dir) Parameters Type Name Description Vector2 dir ComputeVelocity() Declaration protected virtual void ComputeVelocity() FixedUpdate() Declaration protected virtual void FixedUpdate() OnDisable() Declaration protected virtual void OnDisable() OnEnable() Declaration protected virtual void OnEnable() Start() Declaration protected virtual void Start() Teleport(Vector3) Teleport to some position. Declaration public void Teleport(Vector3 position) Parameters Type Name Description Vector3 position Update() Declaration protected virtual void Update()"
  },
  "api/Global.LevelController.html": {
    "href": "api/Global.LevelController.html",
    "title": "Class LevelController | Morpy",
    "keywords": "Class LevelController Inheritance Object LevelController Namespace : Global Assembly : cs.temp.dll.dll Syntax public class LevelController : MonoBehaviour Methods getHighestCompletedLevel() Declaration public static int getHighestCompletedLevel() Returns Type Description Int32 setHighestCompletedLevel(Int32) Declaration public static void setHighestCompletedLevel(int val) Parameters Type Name Description Int32 val"
  },
  "api/Global.LoadLevel.html": {
    "href": "api/Global.LoadLevel.html",
    "title": "Class LoadLevel | Morpy",
    "keywords": "Class LoadLevel Inheritance Object EventManager.Event EventManager.Event < LoadLevel > LoadLevel Inherited Members EventManager.Event<LoadLevel>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class LoadLevel : EventManager.Event<LoadLevel>, IComparable<EventManager.Event> Fields levelName Declaration public string levelName Field Value Type Description String Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.MainMenuScript.html": {
    "href": "api/Global.MainMenuScript.html",
    "title": "Class MainMenuScript | Morpy",
    "keywords": "Class MainMenuScript Inheritance Object MainMenuScript Namespace : Global Assembly : cs.temp.dll.dll Syntax public class MainMenuScript : MonoBehaviour Fields levels Declaration public GameObject[] levels Field Value Type Description GameObject [] levelSelection Declaration public GameObject levelSelection Field Value Type Description GameObject mainMenu Declaration public GameObject mainMenu Field Value Type Description GameObject Methods OpenLevel(Int32) Declaration public void OpenLevel(int level) Parameters Type Name Description Int32 level OpenLevelSelect() Declaration public void OpenLevelSelect() OpenMainMenu() Declaration public void OpenMainMenu() QuitGame() Declaration public void QuitGame() Start() Declaration public void Start() StartGame() Declaration public void StartGame()"
  },
  "api/Global.MorphPlayer.html": {
    "href": "api/Global.MorphPlayer.html",
    "title": "Class MorphPlayer | Morpy",
    "keywords": "Class MorphPlayer Inheritance Object EventManager.Event EventManager.Event < MorphPlayer > MorphPlayer Inherited Members EventManager.Event<MorphPlayer>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class MorphPlayer : EventManager.Event<MorphPlayer>, IComparable<EventManager.Event> Fields gameObject Declaration public GameObject gameObject Field Value Type Description GameObject Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.PauseMenuScript.html": {
    "href": "api/Global.PauseMenuScript.html",
    "title": "Class PauseMenuScript | Morpy",
    "keywords": "Class PauseMenuScript Inheritance Object PauseMenuScript Namespace : Global Assembly : cs.temp.dll.dll Syntax public class PauseMenuScript : MonoBehaviour Fields isPaused Declaration public static bool isPaused Field Value Type Description Boolean pauseButton Declaration public GameObject pauseButton Field Value Type Description GameObject pauseMenuUI Declaration public GameObject pauseMenuUI Field Value Type Description GameObject Methods GoToMenu() Declaration public void GoToMenu() Pause() Declaration public void Pause() reset() Declaration public void reset() Resume() Declaration public void Resume() UpdatePauseStatus() Declaration public void UpdatePauseStatus()"
  },
  "api/Global.PlatformerModel.html": {
    "href": "api/Global.PlatformerModel.html",
    "title": "Class PlatformerModel | Morpy",
    "keywords": "Class PlatformerModel Inheritance Object PlatformerModel Namespace : Global Assembly : cs.temp.dll.dll Syntax [Serializable] public class PlatformerModel Fields enemyArtifactSpawner Spawner for Enemy artifact, on enemy death event Declaration public EnemyArtifactSpawner enemyArtifactSpawner Field Value Type Description EnemyArtifactSpawner highscoreController The main component which controls the highscores Declaration public HighscoreController highscoreController Field Value Type Description HighscoreController jumpDeceleration A global jump modifier applied to slow down an active jump when the user releases the jump input. Declaration public float jumpDeceleration Field Value Type Description Single jumpModifier A global jump modifier applied to all initial jump velocities. Declaration public float jumpModifier Field Value Type Description Single player The main component which controls the player sprite, controlled by the user. Declaration public PlayerController player Field Value Type Description PlayerController spawnPoint The spawn point in the scene. Declaration public Transform spawnPoint Field Value Type Description Transform virtualCamera The virtual camera in the scene. Declaration public Cinemachine.CinemachineVirtualCamera virtualCamera Field Value Type Description Cinemachine.CinemachineVirtualCamera"
  },
  "api/Global.PlayerController.html": {
    "href": "api/Global.PlayerController.html",
    "title": "Class PlayerController | Morpy",
    "keywords": "Class PlayerController Inheritance Object KinematicObject PlayerController Inherited Members KinematicObject.minGroundNormalY KinematicObject.gravityModifier KinematicObject.velocity KinematicObject.invertedMovement KinematicObject.IsGrounded KinematicObject.TargetVelocity KinematicObject.Invert KinematicObject.Bounce(Single) KinematicObject.Bounce(Vector2) KinematicObject.Teleport(Vector3) KinematicObject.OnEnable() KinematicObject.OnDisable() KinematicObject.Start() KinematicObject.FixedUpdate() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class PlayerController : KinematicObject Fields animator Declaration public Animator animator Field Value Type Description Animator collider2d Declaration public BoxCollider2D collider2d Field Value Type Description BoxCollider2D controlEnabled Declaration public bool controlEnabled Field Value Type Description Boolean health Declaration public Health health Field Value Type Description Health jumpState Declaration public PlayerController.JumpState jumpState Field Value Type Description PlayerController.JumpState movementState Declaration public PlayerController.MovementState movementState Field Value Type Description PlayerController.MovementState spriteRenderer Declaration public SpriteRenderer spriteRenderer Field Value Type Description SpriteRenderer targetCharacterType Declaration public CharacterType targetCharacterType Field Value Type Description CharacterType Properties Bounds Declaration public Bounds Bounds { get; } Property Value Type Description Bounds Methods calculateDistanceToObject(GameObject) Declaration public float calculateDistanceToObject(GameObject go) Parameters Type Name Description GameObject go Returns Type Description Single ComputeVelocity() Declaration protected override void ComputeVelocity() Overrides KinematicObject.ComputeVelocity() getNearestEnemyArtifact() Declaration public GameObject getNearestEnemyArtifact() Returns Type Description GameObject morphNearest() Declaration public void morphNearest() Update() Declaration protected override void Update() Overrides KinematicObject.Update()"
  },
  "api/Global.PlayerController.JumpState.html": {
    "href": "api/Global.PlayerController.JumpState.html",
    "title": "Enum PlayerController.JumpState | Morpy",
    "keywords": "Enum PlayerController.JumpState Namespace : Global Assembly : cs.temp.dll.dll Syntax public enum JumpState Fields Name Description Grounded InFlight Jumping Landed PrepareToJump"
  },
  "api/Global.PlayerController.MovementState.html": {
    "href": "api/Global.PlayerController.MovementState.html",
    "title": "Enum PlayerController.MovementState | Morpy",
    "keywords": "Enum PlayerController.MovementState Namespace : Global Assembly : cs.temp.dll.dll Syntax public enum MovementState Fields Name Description Sprinting Standing Walking"
  },
  "api/Global.PlayerDeath.html": {
    "href": "api/Global.PlayerDeath.html",
    "title": "Class PlayerDeath | Morpy",
    "keywords": "Class PlayerDeath Inheritance Object EventManager.Event EventManager.Event < PlayerDeath > PlayerDeath Inherited Members EventManager.Event<PlayerDeath>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class PlayerDeath : EventManager.Event<PlayerDeath>, IComparable<EventManager.Event> Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.PlayerEnteredDeathZone.html": {
    "href": "api/Global.PlayerEnteredDeathZone.html",
    "title": "Class PlayerEnteredDeathZone | Morpy",
    "keywords": "Class PlayerEnteredDeathZone Inheritance Object EventManager.Event EventManager.Event < PlayerEnteredDeathZone > PlayerEnteredDeathZone Inherited Members EventManager.Event<PlayerEnteredDeathZone>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class PlayerEnteredDeathZone : EventManager.Event<PlayerEnteredDeathZone>, IComparable<EventManager.Event> Fields DeathZone Declaration public DeathZone DeathZone Field Value Type Description DeathZone Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.PlayerEnteredGoal.html": {
    "href": "api/Global.PlayerEnteredGoal.html",
    "title": "Class PlayerEnteredGoal | Morpy",
    "keywords": "Class PlayerEnteredGoal Inheritance Object EventManager.Event EventManager.Event < PlayerEnteredGoal > PlayerEnteredGoal Inherited Members EventManager.Event<PlayerEnteredGoal>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class PlayerEnteredGoal : EventManager.Event<PlayerEnteredGoal>, IComparable<EventManager.Event> Fields GoalZone Declaration public GoalZone GoalZone Field Value Type Description GoalZone Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.PlayerSpawn.html": {
    "href": "api/Global.PlayerSpawn.html",
    "title": "Class PlayerSpawn | Morpy",
    "keywords": "Class PlayerSpawn Inheritance Object EventManager.Event EventManager.Event < PlayerSpawn > PlayerSpawn Inherited Members EventManager.Event<PlayerSpawn>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class PlayerSpawn : EventManager.Event<PlayerSpawn>, IComparable<EventManager.Event> Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.RoateDirection.html": {
    "href": "api/Global.RoateDirection.html",
    "title": "Enum RoateDirection | Morpy",
    "keywords": "Enum RoateDirection Namespace : Global Assembly : cs.temp.dll.dll Syntax public enum RoateDirection Fields Name Description DOWN UP"
  },
  "api/Global.RotateToGravity.html": {
    "href": "api/Global.RotateToGravity.html",
    "title": "Class RotateToGravity | Morpy",
    "keywords": "Class RotateToGravity Class for rotating an object with the gravity acting on the device. Inheritance Object RotateToGravity Namespace : Global Assembly : cs.temp.dll.dll Syntax public class RotateToGravity : MonoBehaviour"
  },
  "api/Global.RotateWorld.html": {
    "href": "api/Global.RotateWorld.html",
    "title": "Class RotateWorld | Morpy",
    "keywords": "Class RotateWorld Inheritance Object EventManager.Event EventManager.Event < RotateWorld > RotateWorld Inherited Members EventManager.Event<RotateWorld>.OnExecute EventManager.Event.CompareTo(EventManager.Event) EventManager.Event.Precondition() Namespace : Global Assembly : cs.temp.dll.dll Syntax public class RotateWorld : EventManager.Event<RotateWorld>, IComparable<EventManager.Event> Methods Execute() Declaration public override void Execute() Overrides EventManager.Event.Execute()"
  },
  "api/Global.Sound.html": {
    "href": "api/Global.Sound.html",
    "title": "Class Sound | Morpy",
    "keywords": "Class Sound An audio clip for the Audio Manager Inheritance Object Sound Namespace : Global Assembly : cs.temp.dll.dll Syntax [Serializable] public class Sound Fields clip Declaration public AudioClip clip Field Value Type Description AudioClip loop Declaration public bool loop Field Value Type Description Boolean mixerGroup Declaration public AudioMixerGroup mixerGroup Field Value Type Description AudioMixerGroup name Declaration public string name Field Value Type Description String pitch Declaration public float pitch Field Value Type Description Single pitchVariance Declaration public float pitchVariance Field Value Type Description Single source Declaration public AudioSource source Field Value Type Description AudioSource volume Declaration public float volume Field Value Type Description Single volumeVariance Declaration public float volumeVariance Field Value Type Description Single"
  },
  "api/Global.SpawnPoint.html": {
    "href": "api/Global.SpawnPoint.html",
    "title": "Class SpawnPoint | Morpy",
    "keywords": "Class SpawnPoint Inheritance Object SpawnPoint Namespace : Global Assembly : cs.temp.dll.dll Syntax public class SpawnPoint : MonoBehaviour"
  },
  "index.html": {
    "href": "index.html",
    "title": "Morphy | Morpy",
    "keywords": "Morphy Documentation See here for full documentation: https://emm-gruppe8.github.io/Morphy/ About Morphy is a mobile game centered around movement. Turn, push and pull your phone and discover all the ways in which you can control the charakters, each one unlike the others. Jump high with bunny, use the brute force of the rhino or even turn the world upside down with slime. Only if you take full advantage of their abilities will you be able to escape! Movement Tilt your phone right or left to move into that direction Pull your phone towards you to jump Tap the left side of the screen to attack Tap the right side of the screen to change charakters Charakters Bunny Can Jump Attacks hard by jumping on enemies Rhino Gets very fast Attacks hard by ramming enemies Slime Can walk on floor as well as on ceiling Attacks hard by falling onto enemies"
  },
  "manual/Characters.html": {
    "href": "manual/Characters.html",
    "title": "Bunny | Morpy",
    "keywords": "Bunny Can Jump Kills by Jumping on someone Dies on contact with head into the environment Rhino gets fast kills by smashing someone into wall or pushing into void Slime Can walk on both sides kills by falling onto someone is slow Shell (optional and not realised) moves slowly kills on contact kills on otherside but stays stuck till gravity lets it stand on its feet again Bee (optional and not realised) can fly shots downwards dies on contact with environment"
  },
  "manual/Requirements.html": {
    "href": "manual/Requirements.html",
    "title": "Beschreibung: | Morpy",
    "keywords": "Beschreibung: Der Spieler spielt einen Virus in einem 2D Jump ‘n Run, welcher die Fähigkeiten von Gegnern übernehmen kann. Attackiert und besiegt der Spieler beispielsweise einen fliegenden Gegner, so kann der Spieler nun selber fliegen. Der Spieler kann hierbei immer nur die Fähigkeiten einer Spielfigur gleichzeitig besitzen: Kann der Spieler zur Zeit fliegen und tötet einen Gegner, welcher an Wänden laufen kann, so kann der Spieler nun an Wänden laufen, jedoch nicht mehr fliegen. Der Spieler muss hierbei die Fähigkeiten verschiedener Gegner nutzen, um das Level erfolgreich zu durchqueren, es kommt also auch auf das Geschick des Spielers an, das Level mit den richtigen Fähigkeiten möglichst schnell zu meistern. Plattform: iOS + Android Funktionale Anforderungen 1. Steuerung / Interaktionen Die Spielfigur wird über die Gyroskopsensor bzw. Beschleunigungssensor des Smartphones bewegt. Die Geschwindigkeit der Spielfigur passt sich dabei der Neigung an, sodass diese auch sprinten kann Charaktere verhalten sich unterschiedlich zur Schwerkraft, bzw Interaktion damit Die Angriffe werden über die Touch-Eingabe aktiviert. Der Wechsel zwischen Charakteren wird über Touch-Eingaben aktiviert. Erfüllungsgrad: 100% 2. Leveldesign Es soll in jedem Level Hindernisse geben, die es zu überwinden gilt. Es soll dabei nicht möglich sein, das Level nur mit einer Fähigkeit durchzuspielen, sodass der Spieler gezwungen wird sich andere Fähigkeiten zu besorgen. höhere Hindernisse können durch Springen überwunden werden (Stein) sehr Hohe Hindernisse können nur durch wechsel der Seite (oben/unten) überwunden werden Gräben können nur durch Springen oder Seitenwechsel überwunden werden weite Schluchten können nur mit Sprinten überwunden werden (Springen von Berg) Erfüllungsgrad: 100% 3. Levelfortschritt Es gibt drei unterschiedliche Level, die erst freigeschaltet werden, nachdem das vorherige erfolgreich durchgespielt wurde. Die Level werden dabei schwieriger, um die Herausforderung für geübte Spieler zu erhöhen Erfüllungsgrad: 100% 4. UI und Menüs Im Hauptmenü kann der Spieler direkt weiterspielen, freigeschaltete Level auswählen und seine Zeiten einsehen. Im Pausenmenü kann der Spieler das Spiel pausieren, komplett neustarten und zurück zum Hauptmenü gehen Erfüllungsgrad: 80% 5. Fähigkeit Seitenwechsel Charakter mit dieser Fähikeit sollte beim auf-den-Kopfstellen des Smartphones auf die gegenüberliegende Seite fallen und dort genau so laufen können, wie auf der anderen (Charakter: Slime) Erfüllungsgrad: 100% 6. Fähigkeit Hüpfen Durch Ranziehen des Handys kann der Charakter hüpfen (Charakter: Bunny) Je nach Stärke der Bewegung kann die Höhe des Sprungen moduliert werden Erfüllungsgrad: 100% 7. Fähigkeit übernehmen Die Fähigkeit eines besiegten Gegners kann übernommen werden In der Nähe des Leichnahms kann ein Button gedrückt werden um die Fähigkeit zu übernehmen Erfüllungsgrad: 100% 8. Gegner AI Gegner mit verschiedenen Eigenschaften haben unterschiedliche Verhaltensweisen beim Kampf und in der Fortbewegung und verwenden sie gegen den Spieler Erfüllungsgrad: 100% 9. Gesundheitssystem Der Spieler und die Gegner haben ein Gesundheitssystem basieren auf Health-Points, welche im Fern- oder Nahkampf reduziert werden. Erfüllungsgrad: 100% 10. Kampfsystem Charaktere können durch charakterspezifische Aktionen Gegner sofort Ausschalten (Auf den Kopf springen: Hase, Rammen: Nashorn, Auf Gegner fallen: Slime) Charakter können durch Boxen geringen Schaden ausrichten (für alle Charaktere gleich). Dies wird durch einen virtuellen Button ausgelöst Erfüllungsgrad: 100% (Optional). Bestzeiten Die Zeit, die der Spieler für ein Level benötigt, wird gespeichert, das erhöht den Wiederspielwert, da der Spieler seine eigenen Bestzeiten einsehen kann Erfüllungsgrad: 80% (Optional) Feedback über Vibration des Smartphones Wird der Spieler verletzt, oder stirbt vibriert das Smartphone, um dem Spieler ein besseres Feedback zu geben Erfüllungsgrad: 0% (Optional) Audio Aktionen und Bewegungen verursachen unterschiedliche Töne(Optional) Checkpoints Es können Checkpoints erreicht werden, bei denen der Spieler im Falle seines Todes wieder starten kann. Der Spieler kann dabei jederzeit zum letzten Checkpoint zurückkehren Erfüllungsgrad: 50% (optional) Fähigkeit: Fliegen Charakter “Biene” kann fliegen und aus der Luft angreifen Nach dem Töten des Gegners erscheint an der Stelle der Tötung ein Orb Der Spieler besitzt ein Rand seines Bildschirms einen “Morph” Button, welcher aktiv wird, wenn ein Orb in der Nähe ist Ähnlich zu dem “Report” Button in \"Among Us\" Nach Drücken des Buttons holt der Spieler sich die Fähigkeit des Orbs Der Spieler kann sein Gerät nun neigen, um sich auch hoch unten runter zu bewegen Erfüllungsgrad: 0% (optional) Fähigkeit: Grappling Hook Charakter “Chameleon” kann mit Hilfe der Zunge an Wände, Böden, Decke haften und sich dort selber hinziehen - kann jedoch nicht normal laufen Morphing funktioniert wieder gleich wie unter 5. Fähigkeit: Fliegen Die Fähigkeit kann genutzt werden, in dem auf eine Wand/Decke/Boden getippt wird Erfüllungsgrad: 0% Nicht-Funktionale Anforderungen Benutzerfreundlichkeit in der Bedienung und in den Menüs Unterstützung verschiedener Auflösungen und Bildschirmverhältnisse bei den Smartphones. Erfüllungsgrad: 95%"
  },
  "manual/Sources.html": {
    "href": "manual/Sources.html",
    "title": "Graphic Assets: | Morpy",
    "keywords": "Graphic Assets: “Pixel Adventure 1” https://assetstore.unity.com/packages/2d/characters/pixel-adventure-1-155360 “Pixel Adventure 2” https://assetstore.unity.com/packages/2d/characters/pixel-adventure-2-155418#reviews Pathfinding basis: \"A Pathfinding Project\" * https://arongranberg.com/astar/"
  }
}